// ======================================
// 1) ENV & CORE LIBRARIES
// Initialize dotenv for environment variables
import dotenv from 'dotenv';
dotenv.config();

// Global unhandled promise rejection handler for Puppeteer "Request is already handled!" errors
process.on('unhandledRejection', (reason, promise) => {
  if (reason && reason.message && reason.message.includes('Request is already handled')) {
    console.log('[Puppeteer] Ignoring known issue: Request is already handled');
  } else {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  }
});

import path             from 'path';
import fs               from 'fs';
import { fileURLToPath } from 'url';
import { dirname }      from 'path';

import express          from 'express';
import { createServer } from 'http';
import session          from 'express-session';
import MongoStore       from 'connect-mongo';
import mongoose         from 'mongoose';
import winston          from 'winston';
import { WebSocketServer, WebSocket } from 'ws';
import pRetry           from 'p-retry';
import { v4 as uuidv4 } from 'uuid';
import { Semaphore }    from 'async-mutex';

// Puppeteer extras
import puppeteerExtra   from 'puppeteer-extra';
import StealthPlugin    from 'puppeteer-extra-plugin-stealth';
import { PuppeteerAgent } from '@midscene/web/puppeteer';

// OpenAI SDK
import OpenAI from 'openai';

// ======================================
// 3) MODEL IMPORTS
// ======================================
import User        from './src/models/User.js';
import Message     from './src/models/Message.js';
import Task        from './src/models/Task.js';
import ChatHistory from './src/models/ChatHistory.js';
import Billing     from './src/models/Billing.js';

// ======================================
// 4) UTILS & REPORT GENERATORS
// ======================================
import { stripLargeFields }         from './src/utils/stripLargeFields.js';
import { generateReport }           from './src/utils/reportGenerator.js';
import { editMidsceneReport }       from './src/utils/midsceneReportEditor.js';
import { setupReportServing, setupReportRedirector } from './src/utils/reportFileFixer.js';
import executionHelper               from './src/utils/execution-helper.js';
const { determineExecutionMode }     = executionHelper;

// ======================================
// 5) GLOBAL CONFIGURATION
// ======================================
mongoose.set('strictQuery', true);

const __filename = fileURLToPath(import.meta.url);
const __dirname  = dirname(__filename);

const OPENAI_API_KAIL = process.env.OPENAI_API_KAIL;

// Standardized engine-to-key type mapping
const ENGINE_KEY_MAPPING = {
  'gpt-4o': 'openai',
  'qwen-2.5-vl-72b': 'qwen',
  'gemini-2.5-pro': 'google',
  'ui-tars': 'uitars'
};

// Reverse mapping for key type to engine
const KEY_ENGINE_MAPPING = Object.entries(ENGINE_KEY_MAPPING).reduce((acc, [engine, keyType]) => {
  acc[keyType] = engine;
  return acc;
}, {});

// Function to get a human-readable display name for an engine
function getEngineDisplayName(engineId) {
  const displayNames = {
    'gpt-4o': 'OpenAI GPT-4o',
    'qwen-2.5-vl-72b': 'Qwen 2.5',
    'gemini-2.5-pro': 'Google Gemini',
    'ui-tars': 'UI-TARS'
  };
  return displayNames[engineId] || engineId;
}

// Set up semaphore for limiting concurrent browser instances
const MAX_CONCURRENT_BROWSERS = 5;
const browserSemaphore = new Semaphore(MAX_CONCURRENT_BROWSERS);

/**
 * Checks if a browser session is healthy and operational
 * @param {Object} session - Browser session object
 * @returns {Promise<boolean>} - True if session is healthy
 */
async function isBrowserSessionHealthy(session) {
  if (!session || !session.browser) return false;
  
  try {
    const pages = await session.browser.pages();
    return Array.isArray(pages) && pages.length > 0 && pages[0].isClosed !== true;
  } catch (err) {
    console.log(`Browser health check failed: ${err.message}`);
    return false;
  }
}

puppeteerExtra.use(StealthPlugin());

// Set up session health monitoring to keep browser sessions responsive
const browserSessionHeartbeat = setInterval(async () => {
  console.log(`[BrowserManager] Running heartbeat check on ${activeBrowsers.size} active sessions`);
  const sessionsToClean = [];
  
  for (const [taskId, session] of activeBrowsers.entries()) {
    try {
      // Skip already closed or released sessions
      if (!session || session.closed || session.hasReleased || !session.page) {
        sessionsToClean.push(taskId);
        continue;
      }
      
      // Update last activity timestamp
      if (!session.lastActivity) {
        session.lastActivity = Date.now();
      }
      
      // Check if browser is still responsive
      if (Date.now() - session.lastActivity > 30 * 60 * 1000) { // 30 minutes inactive
        console.log(`[BrowserManager] Cleaning up inactive session ${taskId}`);
        sessionsToClean.push(taskId);
        if (session.release && typeof session.release === 'function') {
          session.release();
        }
        try {
          if (session.page && !session.page.isClosed()) {
            await session.page.close();
          }
          if (session.browser) {
            await session.browser.close();
          }
        } catch (e) {
          console.error(`[BrowserManager] Error cleaning up session: ${e.message}`);
        }
      } else {
        // For active sessions, perform lightweight health check
        if (session.page && !session.page.isClosed()) {
          // Simple heartbeat to keep session alive without causing excessive work
          session.page.evaluate(() => document.title).catch(() => {
            // If this fails, mark for cleanup on next cycle
            session.healthCheckFailed = true;
          });
        }
      }
    } catch (e) {
      console.error(`[BrowserManager] Error in session heartbeat: ${e.message}`);
      sessionsToClean.push(taskId);
    }
  }
  
  // Clean up marked sessions
  for (const taskId of sessionsToClean) {
    activeBrowsers.delete(taskId);
  }
  
  console.log(`[BrowserManager] Heartbeat complete, cleaned ${sessionsToClean.length} sessions, ${activeBrowsers.size} remaining`);
}, 5 * 60 * 1000); // Run every 5 minutes

// OpenAI â€œfallbackâ€ client (used for nonâ€‘userâ€‘key operations)
// Use either OPENAI_API_KEY or fallback to OPENAI_API_KAIL
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY || process.env.OPENAI_API_KAIL });

// Ensure run/report directories exist
const NEXUS_RUN_DIR = path.join(__dirname, 'nexus_run');
fs.mkdirSync(NEXUS_RUN_DIR, { recursive: true });
const REPORT_DIR = path.join(NEXUS_RUN_DIR, 'report');
fs.mkdirSync(REPORT_DIR, { recursive: true });

// Add additional subdirectories if needed
const LOG_DIR = path.join(NEXUS_RUN_DIR, 'logs');
fs.mkdirSync(LOG_DIR, { recursive: true });
const ARTIFACTS_DIR = path.join(NEXUS_RUN_DIR, 'artifacts');
fs.mkdirSync(ARTIFACTS_DIR, { recursive: true });

console.log(`Nexus run directory structure prepared at ${NEXUS_RUN_DIR}`);

// Export paths for use elsewhere in the application
global.NEXUS_PATHS = {
  RUN_DIR: NEXUS_RUN_DIR,
  REPORT_DIR: REPORT_DIR,
  LOG_DIR: LOG_DIR,
  ARTIFACTS_DIR: ARTIFACTS_DIR
};


// ======================================
// 6) EXPRESS + HTTP SERVER
// ======================================
const app    = express();

// Configure CORS
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  if (req.method === 'OPTIONS') return res.sendStatus(200);
  next();
});

// Configure session middleware
const server = createServer(app);

// ======================================
// 7) MIDDLEWARE (ORDER MATTERS)
// ======================================
// 7.1 Body parsers
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// 7.2 Session store (must come before any route that reads/writes req.session)
const MONGO_URI = process.env.MONGO_URI;
app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: MongoStore.create({ mongoUrl: MONGO_URI, collectionName: 'sessions' }),
  cookie: { maxAge: 24 * 60 * 60 * 1000 }
}));

// 7.3 Debug logger for sessions
app.use((req, res, next) => {
  console.log('ðŸ‘‰ Session:', req.sessionID, req.session);
  next();
});

// --- CORS for front-end dev server (allow requests from localhost) ---
app.use((req, res, next) => {
  const origin = req.headers.origin;
  if (origin && origin.startsWith('http://localhost')) {
    res.header('Access-Control-Allow-Origin', origin);
    res.header('Access-Control-Allow-Credentials', 'true');
    res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  }
  if (req.method === 'OPTIONS') return res.sendStatus(200);
  next();
});

// 7.4 Serve static assets
app.use(express.static(path.join(__dirname, 'dist')));
app.use(express.static(path.join(__dirname, 'public')));
// app.use('/css', express.static(path.join(__dirname, 'public', 'css'))); // REMOVED - Handled by dist serving
app.use('/js', express.static(path.join(__dirname, 'public', 'js')));
app.use('/vendors', express.static(path.join(__dirname, 'public', 'vendors'), {
  setHeaders: (res, path) => {
    if (path.match(/\.(woff2?|ttf|otf|eot)$/)) {
      // Add CORS headers for font files
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Methods', 'GET');
      res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
      res.setHeader('Cross-Origin-Resource-Policy', 'cross-origin');
      
      // Set proper MIME types for font files
      if (path.endsWith('.ttf')) {
        res.setHeader('Content-Type', 'font/ttf');
      } else if (path.endsWith('.woff')) {
        res.setHeader('Content-Type', 'font/woff');
      } else if (path.endsWith('.woff2')) {
        res.setHeader('Content-Type', 'font/woff2');
      } else if (path.endsWith('.eot')) {
        res.setHeader('Content-Type', 'application/vnd.ms-fontobject');
      } else if (path.endsWith('.otf')) {
        res.setHeader('Content-Type', 'font/otf');
      }
    }
  }
}));
app.use('/assets', express.static(path.join(__dirname, 'public', 'assets')));
app.use('/images', express.static(path.join(__dirname, 'public', 'assets', 'images')));

// Set up direct report serving first (before static middleware)
setupReportServing(app);
setupReportRedirector(app);

// Serve nexus_run directory
app.use('/nexus_run', express.static(NEXUS_RUN_DIR));

// Handle legacy midscene_run requests by redirecting to nexus_run
app.use('/midscene_run', (req, res, next) => {
  // Extract the path after /midscene_run/
  const subPath = req.path;
  
  // Redirect to the equivalent nexus_run path
  const newPath = `/nexus_run${subPath}`;
  res.redirect(301, newPath);
});
app.use('/models', express.static('public/models'));
app.use('/draco', express.static('public/draco'));

// Serve default favicon
app.get('/favicon.ico', (req, res) => {
  res.sendFile(path.join(__dirname, 'public/assets/images/dail-fav.png'));
});

// Removed old chat-only SSE endpoint; unified SSE below handles both chat and tasks

// ======================================
// 8) ROUTES & MIDDLEWARE IMPORTS
// ======================================
import authRouter       from './src/routes/auth.js';
import historyRouter    from './src/routes/history.js';
import tasksRouter      from './src/routes/tasks.js';
import customUrlsRouter from './src/routes/customUrls.js';
import settingsRouter   from './src/routes/settings.js';
import yamlMapsRouter   from './src/routes/yaml-maps.js';
import { requireAuth }  from './src/middleware/requireAuth.js';
import serveStaticAssets from './src/middleware/staticAssets.js';

// Serve /login for SPA compatibility (redirects /login â†’ /login.html)
app.get('/login', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'login.html'));
});

// Root route - serve appropriate interface
app.get('/', (req, res) => {
  if (req.session.user) {
    res.sendFile(path.join(__dirname, 'dist', 'index.html'));
  } else {
    res.redirect('/login.html');
  }
});

// ======================================
// 9) ROUTERS (after session middleware)
// ======================================
app.use('/api/auth', authRouter);
app.use('/api/settings', settingsRouter);
app.use('/api/history', requireAuth, historyRouter);
import messagesRouter from './src/routes/messages.js';
app.use('/api/messages', requireAuth, messagesRouter);
app.use('/api/tasks',      requireAuth, tasksRouter);
app.use('/api/custom-urls', requireAuth, customUrlsRouter);
app.use('/api/yaml-maps',   requireAuth, yamlMapsRouter);

// Health check endpoint - no auth required
app.get('/api/health', (req, res) => {
  res.status(200).json({ status: 'ok', serverReady: true });
});

// Support legacy /logout path
app.get('/logout', (req, res) => {
  req.session.destroy(err => {
    if (err) console.error('Logout error:', err);
    res.redirect('/login.html');
  });
});

// Serve PWA static assets
serveStaticAssets(app);

// ======================================
// 10) HTML ENDPOINTS & FALLBACK
// ======================================

// -) protect your SPA â€œshellâ€ routes
const guard = (req, res, next) => {
  if (!req.session.user) return res.redirect('/')
  next()
}

// Import API routes
import billingRoutes from './src/routes/billing.js';
import yamlMapsRoutes from './src/routes/yaml-maps.js';

// Use API routes
app.use('/api/billing', billingRoutes);
app.use('/api/yaml-maps', yamlMapsRoutes);

// Loop over the other .html endpoints
const pages = ['history', 'guide', 'settings'];
pages.forEach(page => {
  app.get(`/${page}.html`, guard, (req, res) => {
    res.sendFile(path.join(__dirname, 'dist', `${page}.html`));
  });
});

// Old interface should be accessible without auth
app.get('/old.html', (req, res) => {
  res.sendFile(path.join(__dirname, 'old.html'));
});

// the app shell
app.get('/', guard, (req, res) => {
  // note: index.html is now in dist/
  res.sendFile(path.join(__dirname, 'dist', 'index.html'))
})

// ======================================
// 11) WEBSOCKET SETUP
// ======================================
const userConnections = new Map();
const unsentMessages  = new Map();
const wss = new WebSocketServer({ server, path: '/ws' });

wss.on('connection', (ws, req) => {
  let userIdParam = req.url.split('userId=')[1]?.split('&')[0];
  const userId = decodeURIComponent(userIdParam || '');
  console.debug('[DEBUG] WebSocket connection received for userId:', userId);
  if (!userId) {
    console.error('[WebSocket] Connection rejected: Missing userId');
    ws.send(JSON.stringify({ event: 'error', message: 'Missing userId' }));
    ws.close();
    return;
  }
  ws.userId = userId;
  const userWsSet = userConnections.get(userId) || new Set();
  userWsSet.add(ws);
  userConnections.set(userId, userWsSet);
  console.log(`[WebSocket] Connected: userId=${userId}, total connections=${userWsSet.size}`);

  if (unsentMessages.has(userId)) {
    const queuedMessages = unsentMessages.get(userId);
    queuedMessages.forEach(message => {
      try {
        ws.send(JSON.stringify(message));
      } catch (error) {
        console.error(`[WebSocket] Failed to send queued message to userId=${userId}:`, error);
      }
    });
    unsentMessages.delete(userId);
  }

  ws.on('close', () => {
    const userWsSet = userConnections.get(userId);
    if (userWsSet) {
      userWsSet.delete(ws);
      if (userWsSet.size === 0) {
        userConnections.delete(userId);
      }
      console.log(`[WebSocket] Disconnected: userId=${userId}, remaining connections=${userWsSet.size}`);
    }
  });

  ws.on('error', (error) => {
    console.error(`[WebSocket] Error for userId=${userId}:`, error);
  });

  ws.on('message', (message) => {
    try {
      const data = JSON.parse(message);
      if (data.event === 'debugLog') {
        console.log('[CLIENT DEBUG]', data.message, data.data);
      }
    } catch (e) {
      console.error('WS message parse error:', e);
    }
  });
});

// ======================================
// 12) LOGGER
// ======================================
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(winston.format.timestamp(), winston.format.json()),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({ format: winston.format.simple() }));
}

// ======================================
// 13) STARTUP: DB CONNECT & SERVER LISTEN
// ======================================
async function startApp() {
  try {
    await pRetry(connectToMongoDB, {
      retries: 5,
      minTimeout: 2000,
      onFailedAttempt: error => {
        console.log(`MongoDB connection attempt ${error.attemptNumber} failed. Retrying...`);
      }
    });
    console.log('âœ… MongoDB connected');
    //await clearDatabaseOnce();
    //await ensureIndexes();
    
    const PORT = process.env.PORT || 3420;
    server.listen(PORT, async () => {
      const { address, port } = server.address();
      console.log(`ðŸš€ Nexus server running at http://${address === '::' ? 'localhost' : address}:${port}`);

      // TEMPORARILY DISABLED: Fix all existing report HTML files
      // console.log('Fixing any problematic HTML reports...');
      // const fixedCount = fixAllReports();
      // console.log(`Fixed ${fixedCount || 0} HTML report files`);
    });
  } catch (err) {
    console.error('Failed to start application:', err);
    process.exit(1);
  }
}

await startApp();

// Graceful shutdown on SIGINT.
process.on('SIGINT', async () => {
  console.log('SIGINT received. Shutting down gracefully...');
  try {
    server.close(() => {
      console.log('HTTP server closed.');
    });
    await mongoose.connection.close();
    console.log('Mongoose connection closed.');
  } catch (error) {
    console.error('Error during shutdown:', error);
  } finally {
    process.exit(0);
  }
});

process.on('uncaughtException', (err) => { 
  console.error('Uncaught Exception:', err); 
  process.exit(1); 
});
process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

// Utility sleep function.
async function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function sendWebSocketUpdate(userId, data) {
  // Only send WebSocket updates for streaming events; skip chat HTTP replies
  if (!data.event) {
    console.debug('[WebSocket] Skipped non-event data over WS:', data);
    return;
  }
  console.debug('[DEBUG] sendWebSocketUpdate: userId', userId, 'connections', userConnections.get(userId) ? userConnections.get(userId).size : 0);
  const connections = userConnections.get(userId);
  if (connections && connections.size > 0) {
    connections.forEach(ws => {
      if (ws.readyState === WebSocket.OPEN) {
        try {
          ws.send(JSON.stringify(data));
          console.log('[SERVER] Sending intermediateResult for task:', userId);
          console.log('[SERVER] Sent payload:', data);
        } catch (error) {
          console.error(`[WebSocket] Failed to send to userId=${userId}:`, error);
        }
      } else {
        console.warn(`[WebSocket] Skipping closed connection for userId=${userId}`);
      }
    });
  } else {
    console.debug(`[WebSocket] No active connections for userId=${userId}. Queuing message.`);
    if (!unsentMessages.has(userId)) {
      unsentMessages.set(userId, []);
    }
    unsentMessages.get(userId).push(data);
  }
}

/**
 * Clear the database once.
 */
async function clearDatabaseOnce() {
  const flagFile = path.join(__dirname, 'db_cleared.flag');
  if (fs.existsSync(flagFile)) {
    console.log('Database already cleared, skipping clear operation.');
    return;
  }
  try {
    //await User.deleteMany({});
    await ChatHistory.deleteMany({});
    await Task.deleteMany({});
    console.log('Successfully cleared User, ChatHistory, and Task collections.');
    fs.writeFileSync(flagFile, 'Database cleared on ' + new Date().toISOString());
    console.log('Created db_cleared.flag to mark database clear completion.');
  } catch (err) {
    console.error('Error clearing database:', err);
  }
}

async function connectToMongoDB() {
  const startTime = Date.now();
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
      serverSelectionTimeoutMS: 5000,
      connectTimeoutMS: 10000,
    });
    console.log(`Connected to MongoDB in ${Date.now() - startTime}ms`);
  } catch (err) {
    console.error('Mongoose connection error:', err);
    throw new pRetry.AbortError('MongoDB connection failed after retries');
  }
}

async function ensureIndexes() {
  try {
    await User.ensureIndexes();
    console.log('User indexes ensured');

    await Task.ensureIndexes();
    console.log('Task indexes ensured');
  } catch (err) {
    console.error('Error ensuring indexes:', err);
  }
}

/**
 * Streamlined content processor that only keeps essential information for database storage.
 * Removes images, large content, and unnecessary data to optimize database usage.
 * @param {Object} obj - Object to inspect
 * @returns {Object} - Object with only essential information preserved
 */
function handleLargeContent(obj) {
  // If not an object or null, return as is
  if (!obj || typeof obj !== 'object') return obj;
  
  // For arrays, process each item but limit size
  if (Array.isArray(obj)) {
    // Hard limit of 50 items per array to save space
    if (obj.length > 50) {
      // Don't log this for silent operation
      return obj.slice(0, 50).map(item => handleLargeContent(item));
    }
    return obj.map(item => handleLargeContent(item));
  }
  
  // For objects, process each property with strict filtering
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    // Skip storing these entirely - never needed in DB
    // Only skip screenshot and other large fields, but ALLOW screenshotPath (URL to saved screenshot)
    if (['pageContext', 'rawPageHtml', 'html', 'rawHtml', 
         'dom', 'tree', 'base64', 'image', 'images'].includes(key)) {
      continue; // Skip this field completely
    }
    
    // Special handling for screenshot - we want to keep the URL if it's a string path
    // but remove if it's base64 data
    if (key === 'screenshot') {
      // If it's a string URL/path, keep it. If base64 or null, skip it entirely
      if (typeof value === 'string' && !value.startsWith('data:')) {
        result[key] = value; // Keep screenshot URLs/paths
      } else {
        continue; // Skip base64 screenshots or null values
      }
    }
    
    // Very aggressive limiting for large content fields - always null out full page content
    // This saves significant DB space by not storing any extracted page content at all
    if (['extractedInfo', 'rawPageText', 'pageContent', 'pageText'].includes(key)) {
      // Don't store any page content in the database at all
      result[key] = null;
      // If we need to keep metadata about the extraction, store that instead
      if (typeof value === 'object' && value !== null) {
        // If it has properties like timestamp or metadata, just keep those
        const { timestamp, url, success, metadata } = value;
        if (timestamp) result.timestamp = timestamp;
        if (url) result.url = url;
        if (success !== undefined) result.success = success;
        if (metadata) result.metadata = handleLargeContent(metadata);
      }
    }
    // Remove all base64 images completely
    else if (typeof value === 'string' && value.startsWith('data:image')) {
      // Skip entirely - don't even store a placeholder
      continue;
    }
    // Hard limit on all string fields
    else if (typeof value === 'string' && value.length > 10000) {
      result[key] = value.substring(0, 10000);
    }
    // Process nested objects
    else if (typeof value === 'object' && value !== null) {
      result[key] = handleLargeContent(value);
    }
    // Keep essential values as is
    else {
      result[key] = value;
    }
  }
  return result;
}

/**
 * Update task in database and notify clients with optimized storage.
 * Saves images to filesystem instead of database and retains only essential data.
 * @param {string} taskId - Task ID
 * @param {Object} updates - Updates to apply
 */
async function updateTaskInDatabase(taskId, updates) {
  if (typeof updates !== 'object' || updates === null) {
    console.error(`[Database] Invalid updates parameter: expected an object, received ${typeof updates}`);
    return;
  }
  
  // Create a copy to avoid modifying the original
  const sizeLimitedUpdates = {...updates};
  
  // Process and optimize task data for storage
  console.log(`[TaskCompletion] Applying database size limits to task result...`);
  
  // Helper function to save any image to filesystem
  const saveImageToFile = async (imageData, prefix = 'img') => {
    if (!imageData || typeof imageData !== 'string' || !imageData.startsWith('data:image')) {
      return null;
    }
    
    try {
      // Extract the base64 data
      const base64Data = imageData.replace(/^data:image\/(png|jpeg|jpg);base64,/, '');
      // Create a unique filename
      const filename = `${prefix}-${Date.now()}-${Math.floor(Math.random() * 10000)}.jpg`;
      const filePath = path.join(process.cwd(), 'nexus_run', taskId, filename);
      // Ensure directory exists
      fs.mkdirSync(path.dirname(filePath), { recursive: true });
      // Write the file
      fs.writeFileSync(filePath, Buffer.from(base64Data, 'base64'));
      // Return the URL path
      return `/nexus_run/${taskId}/${filename}`;
    } catch (error) {
      console.error(`[Database] Failed to save image: ${error.message}`);
      return null;
    }
  };

  // Process result object - store only URLs, not images
  if (sizeLimitedUpdates.result) {
    // Main screenshot processing
    if (sizeLimitedUpdates.result.screenshot && typeof sizeLimitedUpdates.result.screenshot === 'string') {
      if (sizeLimitedUpdates.result.screenshot.startsWith('data:image')) {
        // Save image to file and store URL
        const imageUrl = await saveImageToFile(sizeLimitedUpdates.result.screenshot, 'screenshot');
        if (imageUrl) {
          sizeLimitedUpdates.result.screenshotPath = imageUrl;
        }
        // Always remove the base64 data
        delete sizeLimitedUpdates.result.screenshot;
      }
    }
    
    // Preserve only these key URLs that we need
    const keysToKeep = [
      'nexusReportUrl', 'landingReportUrl', 'reportUrl', 'screenshotPath',
      'extractedInfo', 'elementText', 'status', 'error'
    ];
    
    // Create a new result object with only essential data
    const essentialResult = {};
    for (const key of keysToKeep) {
      if (sizeLimitedUpdates.result[key] !== undefined) {
        essentialResult[key] = sizeLimitedUpdates.result[key];
        
        // Further limit text fields
        if (typeof essentialResult[key] === 'string' && essentialResult[key].length > 5000 &&
            key !== 'nexusReportUrl' && key !== 'landingReportUrl' && key !== 'reportUrl' && key !== 'screenshotPath') {
          essentialResult[key] = essentialResult[key].substring(0, 5000);
        }
      }
    }
    
    // Replace the full result with our optimized version
    sizeLimitedUpdates.result = essentialResult;
  }
  
  // Optimize intermediateResults - keep only URLs and essential data
  if (sizeLimitedUpdates.intermediateResults && Array.isArray(sizeLimitedUpdates.intermediateResults)) {
    // Limit to max 50 items
    if (sizeLimitedUpdates.intermediateResults.length > 50) {
      sizeLimitedUpdates.intermediateResults = sizeLimitedUpdates.intermediateResults.slice(0, 50);
    }
    
    // Process each result
    sizeLimitedUpdates.intermediateResults = await Promise.all(
      sizeLimitedUpdates.intermediateResults.map(async (result) => {
        if (!result || typeof result !== 'object') return result;
        
        // Create a simplified version with only essential fields
        const simplified = {};
        
        // Process screenshot/image if present
        if (result.screenshot && typeof result.screenshot === 'string' && 
            result.screenshot.startsWith('data:image')) {
          const imageUrl = await saveImageToFile(result.screenshot, 'step');
          if (imageUrl) {
            simplified.screenshotPath = imageUrl;
          }
        } else if (result.screenshotPath) {
          simplified.screenshotPath = result.screenshotPath;
        }
        
        // Keep only essential text data, limited to reasonable size
        if (result.extractedInfo) {
          simplified.extractedInfo = typeof result.extractedInfo === 'string' 
            ? result.extractedInfo.substring(0, 5000) 
            : result.extractedInfo;
        }
        
        // Copy other essential fields
        ['status', 'error', 'elementText', 'step', 'action'].forEach(key => {
          if (result[key] !== undefined) {
            simplified[key] = result[key];
          }
        });
        
        return simplified;
      })
    );
  }
  
  // Always apply our aggressive content limiter as final step
  sizeLimitedUpdates.result = handleLargeContent(sizeLimitedUpdates.result);
  sizeLimitedUpdates.intermediateResults = handleLargeContent(sizeLimitedUpdates.intermediateResults);
  
  // Ensure all other fields are also optimized
  if (sizeLimitedUpdates.extractedInfo) {
    sizeLimitedUpdates.extractedInfo = handleLargeContent(sizeLimitedUpdates.extractedInfo);
  }
  
  // Remove these entirely - never needed in DB
  ['pageContent', 'rawPageText', 'rawHtml', 'html'].forEach(key => {
    if (sizeLimitedUpdates[key]) {
      delete sizeLimitedUpdates[key];
    }
  });
  
  // Other potentially large fields - simplify aggressively
  if (sizeLimitedUpdates.stepMap) {
    // Just keep the structure but remove large content
    sizeLimitedUpdates.stepMap = handleLargeContent(sizeLimitedUpdates.stepMap);
  }
  
  console.log(`[Database] Updating task ${taskId}:`, Object.keys(sizeLimitedUpdates));
  try {
    // Atomically update task and retrieve the modified document
    const task = await Task.findByIdAndUpdate(
      new mongoose.Types.ObjectId(taskId),
      { $set: sizeLimitedUpdates },
      { new: true }
    );
    if (!task) {
      console.error(`[Database] Task ${taskId} not found`);
      return;
    }
    let eventName;
    if (updates.status === 'pending') eventName = 'taskStart';
    else if (updates.status === 'completed') {
      eventName = 'taskComplete';
      // Ensure we're not losing report URLs in the payload
      if (updates.result) {
        // Log the values to ensure they're being properly passed
        console.log(`[TaskCompletion] Sending task completion event for task ${taskId} with URLs:`, {
          landingReportUrl: updates.result.landingReportUrl,
          nexusReportUrl: updates.result.nexusReportUrl,
          reportUrl: updates.result.reportUrl,
          screenshot: updates.result.screenshot
        });
      }
    }
    else if (updates.status === 'error') eventName = 'taskError';
    else if ('progress' in updates) eventName = 'stepProgress';
    else if ('intermediateResults' in updates) eventName = 'intermediateResult';
    else eventName = 'taskUpdate';
    sendWebSocketUpdate(task.userId.toString(), { event: eventName, payload: { taskId, ...updates } });
  } catch (error) {
    console.error(`[Database] Error updating task:`, error);
  }
}

/**
 * Process task completion and generate reports.
 * @param {string} userId - User ID
 * @param {string} taskId - Task ID
 * @param {Array} intermediateResults - Intermediate results
 * @param {string} originalPrompt - Original user prompt
 * @param {string} runDir - Run directory
 * @param {string} runId - Run ID
 * @returns {Object} - Final result
 */
async function processTaskCompletion(userId, taskId, intermediateResults, originalPrompt, runDir, runId) {
  console.log(`[TaskCompletion] Processing completion for task ${taskId}`);
  try {
    let finalScreenshot = null;
    let lastTaskId = null;
    let agent = null;
    if (intermediateResults.length > 0) {
      const lastResult = intermediateResults[intermediateResults.length - 1];
      if (lastResult.task_id && activeBrowsers.has(lastResult.task_id)) {
        lastTaskId = lastResult.task_id;
        const { page, agent: activeAgent } = activeBrowsers.get(lastResult.task_id);
        finalScreenshot = await page.screenshot({ encoding: 'base64' });
        agent = activeAgent;
      }
      // Only use lastResult.screenshot if it's not a base64 string (should be a URL)
      if (lastResult.screenshot && !lastResult.screenshot.startsWith('data:image')) {
        finalScreenshotUrl = lastResult.screenshot; // It's already a URL, just use it
      } else if (lastResult.screenshot) {
        // If it's a base64 string, we'll save it to a file below
        finalScreenshot = lastResult.screenshot;
      }
    }
    let finalScreenshotUrl = null;
    if (finalScreenshot) {
      const finalScreenshotPath = path.join(runDir, `final-screenshot-${Date.now()}.png`);
      fs.writeFileSync(finalScreenshotPath, Buffer.from(finalScreenshot, 'base64'));
      console.log(`[TaskCompletion] Saved final screenshot to ${finalScreenshotPath}`);
      finalScreenshotUrl = `/nexus_run/${runId}/${path.basename(finalScreenshotPath)}`;
    }

    const landingReportPath = await generateReport(
      originalPrompt,
      intermediateResults,
      finalScreenshotUrl,
      runId,
      REPORT_DIR
    );
    let midsceneReportPath = null;
    let nexusReportUrl = null;
    if (agent) {
      await agent.writeOutActionDumps();
      midsceneReportPath = agent.reportFile;
      if (midsceneReportPath && fs.existsSync(midsceneReportPath)) {
        try {
          // Try to use the imported function if it exists
          midsceneReportPath = await editMidsceneReport(midsceneReportPath);
          console.log(`[MidsceneReport] Updated report at ${midsceneReportPath}`);
        } catch (error) {
          // If there's an error, just use the original path
          console.warn(`[MidsceneReport] Error editing report: ${error.message}`);
        }
        nexusReportUrl = `/nexus_run/report/${path.basename(midsceneReportPath)}`;
      }
    }

    const rawPageText = intermediateResults
      .map(step => (step && step.result && step.result.extractedInfo) || '')
      .join('\n');

    const currentUrl = (intermediateResults[intermediateResults.length - 1]?.result?.currentUrl) || 'N/A';
    const summary = intermediateResults[intermediateResults.length - 1]?.result?.actionOutput ||
      `Task execution completed for: ${originalPrompt}`;

    // Enhanced logging for report URLs - helps with debugging
    const landingReportUrl = landingReportPath ? `/nexus_run/report/${path.basename(landingReportPath)}` : null;
    console.log(`[TaskCompletion] Enhanced report links for task ${taskId}:`, { 
      landingReportPath,
      midsceneReportPath,
      landingReportUrl,
      nexusReportUrl,
      finalScreenshotUrl,
      reportExists: landingReportPath ? fs.existsSync(landingReportPath) : false,
      midsceneExists: midsceneReportPath ? fs.existsSync(midsceneReportPath) : false
    });
    
    // Make sure we have at least one valid report URL
    let primaryReportUrl = null;
    
    // Check and verify each possible report URL in order of preference
    if (nexusReportUrl) {
      const relPath = nexusReportUrl.replace('/nexus_run/report/', '');
      const absPath = path.join(REPORT_DIR, relPath);
      if (fs.existsSync(absPath)) {
        primaryReportUrl = nexusReportUrl;
        console.log(`[TaskCompletion] Using verified nexusReportUrl: ${nexusReportUrl}`);
      } else {
        console.warn(`[TaskCompletion] nexusReportUrl points to non-existent file: ${absPath}`);
      }
    }
    
    if (!primaryReportUrl && landingReportUrl) {
      const relPath = landingReportUrl.replace('/nexus_run/report/', '');
      const absPath = path.join(REPORT_DIR, relPath);
      if (fs.existsSync(absPath)) {
        primaryReportUrl = landingReportUrl;
        console.log(`[TaskCompletion] Using verified landingReportUrl: ${landingReportUrl}`);
      } else {
        console.warn(`[TaskCompletion] landingReportUrl points to non-existent file: ${absPath}`);
      }
    }
    
    // Final fallback to screenshot
    if (!primaryReportUrl && finalScreenshotUrl) {
      primaryReportUrl = finalScreenshotUrl;
      console.log(`[TaskCompletion] Falling back to screenshot URL: ${finalScreenshotUrl}`);
    }
    
    // Compose a lean result object for success (only essential fields, no raw page content)
    // Only include urls and metadata, not full page content to save DB space
    let finalResult = {
      success: true,
      taskId,
      raw: {
        // Don't store the full page text to save DB space
        pageText: null, 
        url: currentUrl
      },
      aiPrepared: {
        summary: summary
      },
      screenshot: finalScreenshotUrl,
      // Only store essential step data, not full content or large objects
      steps: intermediateResults.map(step => {
        if (step.getSummary) {
          return step.getSummary();
        } else {
          // Make sure we're not storing large objects in steps
          const { result, ...stepData } = step;
          return {
            ...stepData,
            // Only keep success, currentUrl, and essential fields from result
            result: result ? {
              success: result.success,
              currentUrl: result.currentUrl,
              // Don't store full extractedInfo or navigableElements
              extractedInfo: null,
              navigableElements: null
            } : null
          };
        }
      }),
      landingReportUrl: landingReportUrl,
      nexusReportUrl: nexusReportUrl || null,
      runReport: landingReportUrl, // alias for frontend
      // Don't store full intermediate results to save DB space
      intermediateResults: [], 
      error: null,
      // For compatibility, always provide a reportUrl with verified URL
      reportUrl: primaryReportUrl
    };
    
    // Apply size limiting to the entire finalResult object to ensure it fits in MongoDB's 16MB limit
    console.log('[TaskCompletion] Applying database size limits to task result...');
    finalResult = handleLargeContent(finalResult);
    console.log('[TaskCompletion] Size limiting complete');

    return finalResult;
  } catch (error) {
    console.error(`[TaskCompletion] Error:`, error);
    const errorReportFile = `error-report-${Date.now()}.html`;
    const errorReportPath = path.join(REPORT_DIR, errorReportFile);
    
    // Create a proper HTML error report rather than just a string
    const errorHtml = `
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Nexus Error Report</title>
        <style>
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #eee;
            background-color: #1a1a2e;
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
          }
          .error-box {
            background-color: #272741;
            border-left: 5px solid #fd3259;
            padding: 1rem 2rem;
            margin: 2rem 0;
            border-radius: 0 5px 5px 0;
          }
          pre {
            background-color: #0f0f1b;
            padding: 1rem;
            border-radius: 5px;
            overflow-x: auto;
          }
          h1, h2 {
            color: #4cc9f0;
          }
          .nexus-logo {
            text-align: center;
            margin-bottom: 2rem;
          }
          .timestamp {
            color: #aaa;
            font-size: 0.9rem;
          }
        </style>
      </head>
      <body>
        <div class="nexus-logo">
          <h1>Nexus</h1>
        </div>
        
        <h2>Task Error Report</h2>
        <p class="timestamp">Generated on: ${new Date().toLocaleString()}</p>
        
        <div class="error-box">
          <h3>Error Details</h3>
          <pre>${error.message || 'Unknown error'}</pre>
          ${error.stack ? `<h3>Stack Trace</h3><pre>${error.stack}</pre>` : ''}
        </div>
      </body>
    </html>
    `;
    
    fs.writeFileSync(errorReportPath, errorHtml);
    
    // Compose a full result object for error (all fields, nulls for missing, error fields set)
    // Try to extract any available screenshot or report URLs from intermediate results
    let errorScreenshot = null;
    let errorLandingReportUrl = null;
    let errornexusReportUrl = null;
    let errorRunReport = null;
    
    // Safely access intermediate results with null/undefined checks
    if (Array.isArray(intermediateResults) && intermediateResults.length > 0) {
      const lastResult = intermediateResults[intermediateResults.length - 1];
      if (lastResult && typeof lastResult === 'object') {
        // Safely check each property
        if (lastResult.screenshot) errorScreenshot = lastResult.screenshot;
        if (lastResult.landingReportUrl) errorLandingReportUrl = lastResult.landingReportUrl;
        if (lastResult.nexusReportUrl) errornexusReportUrl = lastResult.nexusReportUrl;
        if (lastResult.runReport) errorRunReport = lastResult.runReport;
      }
    }
    // Return a minimal error result with no raw page content
    const errorResult = {
      success: false,
      taskId,
      raw: { pageText: null, url: null },
      aiPrepared: { summary: null },
      screenshot: errorScreenshot,
      steps: [], // Don't save any steps data on error
      landingReportUrl: errorLandingReportUrl,
      nexusReportUrl: `/nexus_run/report/${errorReportFile}`,
      runReport: errorRunReport,
      intermediateResults: [], // Explicitly empty intermediateResults 
      error: error.message,
      // Always provide a reportUrl for error compatibility
      reportUrl: `/nexus_run/report/${errorReportFile}`
    };
    
    // Log the error result structure for debugging
    console.log(`[TaskCompletion] Returning error result structure:`, JSON.stringify({
      success: errorResult.success,
      hasError: !!errorResult.error,
      errorMsg: errorResult.error,
      reportUrls: {
        nexusReportUrl: errorResult.nexusReportUrl,
        landingReportUrl: errorResult.landingReportUrl,
        reportUrl: errorResult.reportUrl
      }
    }));
    
    return errorResult;

  } finally {
    if (activeBrowsers.size > 0) {
      for (const [id, session] of activeBrowsers.entries()) {
        if (!session.closed) {
          try {
            await session.browser.close();
            // Handle release with better type checking and error handling
            if (session.release !== undefined) {
              if (typeof session.release === 'function') {
                try {
                  session.release();
                  console.debug(`[TaskCompletion] Successfully released semaphore for session ${id}`);
                } catch (e) {
                  console.debug(`[TaskCompletion] Error releasing semaphore for session ${id}:`, e);
                }
              } else {
                console.warn(`[TaskCompletion] release is ${typeof session.release} for session ${id}, attempting to call anyway`);
                try {
                  // Try to call it if it's not undefined (might be a promise or other callable)
                  const result = session.release;
                  if (result && typeof result.then === 'function') {
                    // Handle if it's a promise
                    result.catch(e => console.debug(`[TaskCompletion] Error from release promise for session ${id}:`, e));
                  }
                } catch (e) {
                  console.debug(`[TaskCompletion] Error handling non-function release for session ${id}:`, e);
                }
              }
            } else {
              console.warn(`[TaskCompletion] release is not defined for session ${id}, skipping release`);
            }
            session.closed = true;
            activeBrowsers.delete(id);
            console.log(`[TaskCompletion] Closed browser session ${id}`);
          } catch (error) {
            console.error(`[TaskCompletion] Error closing browser session ${id}:`, error);
          }
        }
      }
    }
  }
}



// Sessions map - shared across the application
const activeBrowsers = new Map();

/**
 * TaskPlan - Class to manage the execution plan for a browser task
 */
class TaskPlan {
  constructor(userId, taskId, prompt, initialUrl, runDir, runId, maxSteps = 10) {
    this.userId = userId;
    this.taskId = taskId;
    this.prompt = prompt;
    this.initialUrl = initialUrl;
    this.runDir = runDir;
    this.runId = runId;
    this.steps = [];
    this.currentStepIndex = -1;
    this.maxSteps = maxSteps;
    this.currentState = [];          // Array to store all state objects (assertions, page states, etc.)
    this.extractedInfo = [];         // Array to keep a history of extracted info
    this.navigatableElements = [];   // Array to hold navigable elements (can be cumulative)
    this.planLog = [];
    this.completed = false;
    this.summary = null;    
    this.currentUrl = initialUrl || 'Not specified';
    // Store the user's OpenAI API key for use in PuppeteerAgent initialization.
    this.userOpenaiKey = null;
    // Store the browser session for reuse across steps
    this.browserSession = null;
  }

  log(message, metadata = {}) {
    const entry = { timestamp: new Date().toISOString(), message, ...metadata };
    this.planLog.push(entry);
    console.log(`[Task ${this.taskId}] ${message}`, metadata);
    sendWebSocketUpdate(this.userId, { event: 'planLog', taskId: this.taskId, message, metadata });
  }

  /**
   * Create a new step in the plan.
   * After execution, a short step summary is generated and stored in step.stepSummary.
   * @param {string} type - 'action' or 'query'
   * @param {string} instruction - Instruction for the step
   * @param {Object} args - Associated arguments
   * @returns {PlanStep} - The created step.
   */
  createStep(type, instruction, args) {
    const step = {
      index: this.steps.length,
      type,
      instruction,
      args,
      status: 'pending',
      result: null,
      error: null,
      execute: async (plan) => {
        try {
          step.status = 'running';
          plan.log(`Executing step ${step.index + 1}: ${step.type} - ${step.instruction}`);
          let result;
          if (step.type === 'action') {
            result = await plan.executeBrowserAction(step.args, step.index);
          } else {
            result = await plan.executeBrowserQuery(step.args, step.index);
          }
          step.result = result;
          step.status = result.success ? 'completed' : 'failed';
          plan.currentUrl = result.currentUrl || plan.currentUrl;
          if (result.state) {
            plan.updateGlobalState(result);
          }
          plan.log(`Step ${step.index + 1} ${step.status}`);
          return result;
        } catch (error) {
          step.status = 'failed';
          step.error = error.message;
          plan.log(`Step ${step.index + 1} failed: ${error.message}`, { stack: error.stack });
          return { success: false, error: error.message, currentUrl: plan.currentUrl };
        }
      },
      getSummary: () => ({
        index: step.index,
        type: step.type,
        instruction: step.instruction,
        status: step.status,
        success: step.result?.success || false,
        stepSummary: step.stepSummary || 'No summary'
      })
    };
    this.steps.push(step);
    this.currentStepIndex = this.steps.length - 1;
    return step;
  }

  getCurrentStep() {
    if (this.currentStepIndex >= 0 && this.currentStepIndex < this.steps.length) {
      return this.steps[this.currentStepIndex];
    }
    return null;
  }

  markCompleted(summary) {
    this.completed = true;
    this.summary = summary;
    this.log(`Task marked as completed: ${summary}`);
  }

   /**
   * Helper method to update globals when a result is received.
   */
   updateGlobalState(result) {
    if (result.state && result.state.assertion) {
      this.currentState.push({ assertion: result.state.assertion });
    } else if (this.currentState.length === 0) {
      this.currentState.push({ assertion: 'No assertion available' });
    }
    
    let extracted = 'No extracted info available';
    if (result.extractedInfo) {
      if (typeof result.extractedInfo === 'object' && result.extractedInfo.pageContent) {
        extracted = result.extractedInfo.pageContent;
      } else if (typeof result.extractedInfo === 'string') {
        extracted = result.extractedInfo;
      }
    }
    this.extractedInfo.push(extracted);
    
    if (result.navigableElements && Array.isArray(result.navigableElements)) {
      this.navigatableElements = this.navigatableElements.concat(result.navigableElements);
    } else if (this.navigatableElements.length === 0) {
      this.navigatableElements = [];
    }
  }

  /**
   * Generate a system prompt that includes progress and state details.
   * @returns {string} - The generated system prompt.
   */
  generateSystemPrompt() {
    const latestState = (Array.isArray(this.currentState) && this.currentState.length)
      ? this.currentState[this.currentState.length - 1]
      : { assertion: 'No assertion available' };
    const assertionSummary = latestState.assertion || 'No assertion available';

    const latestExtracted = (Array.isArray(this.extractedInfo) && this.extractedInfo.length)
      ? this.extractedInfo[this.extractedInfo.length - 1]
      : 'No extracted info available';
    const extractedSummary = latestExtracted
      ? latestExtracted.substring(0, 700) + '...'
      : 'No extracted info available';

    const progressSummary = this.steps.length > 0
      ? this.steps.map(step => 
          `- Step ${step.index + 1}: ${step.type.toUpperCase()} - ${step.instruction} (${step.status})`
        ).join('\n')
      : 'No steps executed yet';

    const lastStepSummary = (this.steps.length > 0 && this.steps[this.steps.length - 1].stepSummary)
      ? this.steps[this.steps.length - 1].stepSummary
      : 'No summary available';

    const recentFailures = this.steps.slice(-3)
      .filter(step => step.status === 'failed')
      .map(step => 
        `- Step ${step.index + 1}: ${step.instruction} failed (${step.error || 'Unknown error'})`
      ).join('\n') || 'No recent failures';

    return `
You are an AI assistant automating browser tasks with resilience and adaptability. 
You never fail to accomplish the task and reason all steps until you accomplish it. 
You always instruct towards achieving the "Main Task".

GUIDELINES:
1. PERSISTENCE: Never give up on a task. If one approach fails, try alternative methods.
2. AUTONOMY: You must determine steps needed without user input after initial request.
3. PLANNING: You can take in a plan and execute it, or create a step-by-step plan based on previous results.
4. ADAPTABILITY: Adjust your plan based on new information. Analyze all changes in new information carefully to see differences then decide.
5. COMMUNICATION: Clearly explain your actions and reasoning.
6. PROGRESS TRACKING: Indicate task progress and status.
7. EXTRACTING DATA: Always provide instructions to extract all necessary page data.
8. NAVIGATION EFFICIENCY: Check the current page before navigating.
9. NEXT STEP PRECISION: Plan incremental steps based on the latest state and data.
CURRENT TASK: "${this.prompt}"
Starting URL: ${this.initialUrl || 'Not specified'}
Current Step: ${this.currentStepIndex + 1} of ${this.maxSteps}
Current URL: ${this.currentUrl || 'Not yet navigated'}

PROGRESS SUMMARY (based on previous step): ${lastStepSummary}
FULL STEP SUMMARY:
${progressSummary}
Recent Failures:
${recentFailures}
Extracted Information:
- ${extractedSummary}
Assertion (Page State):
- ${assertionSummary}

[END OF SUMMARY]

Proceed with actions toward the Main Task: "${this.prompt}".
    `.trim();
  }

  getSummary() {
    return {
      taskId: this.taskId,
      prompt: this.prompt,
      initialUrl: this.initialUrl,
      currentUrl: this.currentUrl,
      steps: this.steps.map(step => step.getSummary()),
      completed: this.completed,
      summary: this.summary,
      planLog: this.planLog,
      currentStepIndex: this.currentStepIndex,
      maxSteps: this.maxSteps
    };
  }

  async executeBrowserAction(args, stepIndex) {
    // Pass current URL to avoid unnecessary navigation on subsequent steps
    if (!args.url && this.currentUrl && this.currentUrl !== 'Not specified') {
      args.url = this.currentUrl;
    }
    
    // Execute the action, passing in our existing browser session
    const result = await handleBrowserAction(
      args,
      this.userId,
      this.taskId,
      this.runId,
      this.runDir,
      stepIndex,
      this.browserSession
    );
    
    // If the result has a browserSession, store it for future steps
    if (result.browserSession) {
      this.browserSession = result.browserSession;
      this.log('Browser session maintained for future steps');
    }
    
    return result;
  }

  async executeBrowserQuery(args, stepIndex) {
    // Pass current URL to avoid unnecessary navigation on subsequent steps
    if (!args.url && this.currentUrl && this.currentUrl !== 'Not specified') {
      args.url = this.currentUrl;
    }
    
    // Execute the query, passing in our existing browser session
    const result = await handleBrowserQuery(
      args,
      this.userId,
      this.taskId,
      this.runId,
      this.runDir,
      stepIndex,
      this.browserSession
    );
    
    // If the result has a browserSession, store it for future steps
    if (result.browserSession) {
      this.browserSession = result.browserSession;
      this.log('Browser session maintained for future steps');
    }
    
    return result;
  }

  updateBrowserSession(session) {
    this.browserSession = session;
    if (session && session.currentUrl) {
      this.currentUrl = session.currentUrl;
    }
    this.log(`Updated browser session, current URL: ${this.currentUrl}`);
  }
}

/**
 * PlanStep - Class to manage an individual step in the execution plan
 */
class PlanStep {
  constructor(index, type, instruction, args, userId, taskId, runDir) {
    this.index = index;
    this.type = type;
    this.instruction = instruction;
    this.args = args;
    this.userId = userId;
    this.taskId = taskId;
    this.runDir = runDir;
    this.status = 'pending';
    this.result = null;
    this.startTime = new Date();
    this.endTime = null;
    this.logs = [];
    this.error = null;
    this.stepSummary = null; 
  }

  log(message, data = null) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      step: this.index,
      message,
      data: data ? (typeof data === 'object' ? JSON.stringify(data) : data) : null
    };
    this.logs.push(logEntry);
    console.log(`[PlanStep:${this.index}] ${message}`);
  }

  async generateStepSummary() {
    if (this.stepSummary) return this.stepSummary;
    try {
      const summaryResponse = await openai.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: 'Summarize the following step result in at most 5 tokens:' },
          { role: 'user', content: JSON.stringify(this.getSummary()) }
        ],
        temperature: 0,
        max_tokens: 5
      });
      const summary = summaryResponse.choices[0].message.content.trim();
      this.stepSummary = summary;
      return summary;
    } catch (error) {
      console.error(`Error generating step summary: ${error.message}`);
      this.stepSummary = 'No summary';
      return this.stepSummary;
    }
  }

  async execute(plan) {
    this.log(`Starting execution: ${this.type} - ${this.instruction}`);
    this.status = 'running';
    
    try {
      const trimmedStepLogs = this.logs.map(entry => {
        const shortMsg = entry.message.length > 150 ? entry.message.substring(0, 150) + '...' : entry.message;
        return { ...entry, message: shortMsg };
      });
      sendWebSocketUpdate(this.userId, { 
        event: 'stepProgress', 
        taskId: this.taskId, 
        stepIndex: this.index, 
        progress: 10, 
        message: `Starting: ${this.instruction}`,
        log: trimmedStepLogs
      });
  
      let result;
      if (this.type === 'action') {
        result = await plan.executeBrowserAction(this.args, this.index);
      } else {
        result = await plan.executeBrowserQuery(this.args, this.index);
      }
      this.result = result;
      this.status = result.success ? 'completed' : 'failed';
      this.endTime = new Date();
      
      // Update the planâ€™s global state.
      plan.updateGlobalState(result);
      plan.extractedInfo = result.extractedInfo || 'No content extracted';
      plan.updateBrowserSession({ currentUrl: result.currentUrl });
      if (result.state) {
        plan.currentState = result.state;
      } else {
        plan.currentState = {
          pageDescription: 'No content extracted',
          navigableElements: [],
          currentUrl: result.currentUrl || plan.currentUrl
        };
      }
  
      const trimmedActionLogs = (result.actionLog || []).map(entry => {
        const shortMsg = entry.message.length > 150 ? entry.message.substring(0, 150) + '...' : entry.message;
        return { ...entry, message: shortMsg };
      });
  
      const finalTrimmedStepLogs = this.logs.map(entry => {
        const shortMsg = entry.message.length > 150 ? entry.message.substring(0, 150) + '...' : entry.message;
        return { ...entry, message: shortMsg };
      });
  
      sendWebSocketUpdate(this.userId, { 
        event: 'stepProgress', 
        taskId: this.taskId, 
        stepIndex: this.index, 
        progress: 100, 
        message: this.status === 'completed' ? 'Step completed' : 'Step failed',
        log: [...finalTrimmedStepLogs, ...trimmedActionLogs]
      });
  
      console.log(`[Task ${this.taskId}] Step ${this.index} completed`, {
        status: this.status,
        type: this.type,
        url: result.currentUrl
      });
      
      await this.generateStepSummary();
  
      return result;
    } catch (error) {
      this.log(`Error executing step: ${error.message}`);
      this.status = 'failed';
      this.endTime = new Date();
      this.error = error.message;
      
      const trimmedLogs = this.logs.map(entry => {
        const shortMsg = entry.message.length > 150 ? entry.message.substring(0, 150) + '...' : entry.message;
        return { ...entry, message: shortMsg };
      });
  
      sendWebSocketUpdate(this.userId, { 
        event: 'stepProgress', 
        taskId: this.taskId, 
        stepIndex: this.index, 
        progress: 100, 
        message: `Error: ${error.message}`,
        log: trimmedLogs
      });
      
      console.log(`[Task ${this.taskId}] Step ${this.index} failed`, { error: error.message });
      
      return {
        success: false,
        error: error.message,
        actionLog: trimmedLogs,
        currentUrl: plan.currentUrl,
        task_id: this.taskId,
        stepIndex: this.index
      };
    }
  }

  getSummary() {
    return {
      index: this.index,
      type: this.type,
      instruction: this.instruction,
      args: this.args,
      status: this.status,
      startTime: this.startTime,
      endTime: this.endTime,
      duration: this.endTime ? (this.endTime - this.startTime) : null,
      resultSummary: this.result ? {
        success: this.result.success,
        currentUrl: this.result.currentUrl,
        error: this.result.error,
        extractedInfo: this.result.extractedInfo,
        navigableElements: this.result.navigableElements
      } : null,
      logs: this.logs,
      error: this.error,
      stepSummary: this.stepSummary
    };
  }
}
/**
 * Get an OpenAI client for this user, specifically configured for CHAT PURPOSES ONLY.
 * This simplified function handles chat models (GPT-4o, Claude, Gemini, etc.)
 * 
 * TODO: This function needs proper SDK implementation for non-OpenAI providers:
 * - Currently only OpenAI models (GPT-4o, GPT-4o-mini, GPT-3.5-turbo) are fully supported
 * - Claude models require the Anthropic SDK with different parameters
 * - Gemini models need Google's generative AI SDK
 * - Grok models have OpenAI-compatible API but may need specific streaming setup
 * 
 * The current implementation returns an OpenAI client which will only work properly with
 * OpenAI models. For other providers, we need to modify streamNliThoughts() to handle
 * the different client SDKs and request formats.
 * 
 * Note: This is NOT used for browser automation, which is handled by setupNexusEnvironment().
 */
async function getUserOpenAiClient(userId) {
  // Define standard default keys for different providers
  const DEFAULT_KEYS = {
    'openai': process.env.DEFAULT_GPT4O_KEY || '',
    'qwen': process.env.DEFAULT_OPENROUTER_KEY || '',
    'google': process.env.DEFAULT_GEMINI_KEY || '',
    'anthropic': process.env.DEFAULT_CLAUDE_KEY || '',
    'xai': process.env.DEFAULT_GROK_KEY || ''
  };
  
  // Define provider-specific base URLs
  const PROVIDER_BASE_URLS = {
    'openai': process.env.CUSTOM_OPENAI_ENDPOINT || undefined,
    'anthropic': 'https://api.anthropic.com',
    'google': 'https://generativelanguage.googleapis.com/v1beta/openai/',
    'qwen': 'https://openrouter.ai/api/v1',
    'xai': 'https://api.groq.com/openai/v1'
  };
  
  // Map from model to provider
  const MODEL_PROVIDER_MAPPING = {
    // OpenAI models
    'gpt-4o': 'openai',
    'gpt-4o-mini': 'openai',
    'gpt-3.5-turbo': 'openai',
    // Claude models
    'claude-3-opus': 'anthropic',
    'claude-3-sonnet': 'anthropic',
    'claude-3-haiku': 'anthropic',
    // Gemini models
    'gemini-1.5-pro': 'google',
    'gemini-1.5-flash': 'google',
    // Grok models
    'grok-1': 'xai'
  };
  
  // Track whether we're using a default key
  let usingDefaultKey = false;
  let keySource = 'user';
  
  // Fetch user's preferences and API keys
  const user = await User
    .findById(userId)
    .select('openaiApiKey apiKeys preferredEngine modelPreferences')
    .lean();

  if (!user) {
    console.error(`[OpenAIClient] User ${userId} not found, using default GPT-4o key`);
    usingDefaultKey = true;
    keySource = 'system-default';
    return new OpenAI({ 
      apiKey: DEFAULT_KEYS['openai'],
      defaultQuery: { usingDefaultKey, keySource, engine: 'gpt-4o', provider: 'openai' }
    });
  }

  // Get the user's preferred chat model, defaulting to gpt-4o if not set
  let preferredModel = user?.modelPreferences?.chat || 'gpt-4o';
  console.log(`[Chat] Using chat model preference: ${preferredModel}`);
  
  // Determine the provider for this model
  const provider = MODEL_PROVIDER_MAPPING[preferredModel] || 'openai';
  
  // If model isn't supported, fall back to gpt-4o
  if (!provider) {
    console.warn(`[OpenAIClient] Unsupported model ${preferredModel}, falling back to gpt-4o`);
    preferredModel = 'gpt-4o';
  }
  
  // Get the base URL for this provider
  const baseURL = PROVIDER_BASE_URLS[provider];
  
  // Map from provider to schema key in User model
  const PROVIDER_SCHEMA_MAPPING = {
    'openai': 'gpt4o',
    'anthropic': 'claude',
    'google': 'gemini',
    'xai': 'grok',
    'qwen': 'qwen'
  };

  // Get the schema key for the user's API keys
  const schemaKey = PROVIDER_SCHEMA_MAPPING[provider];
  
  // Check for the appropriate API key
  let apiKey;
  
  // First try user's stored key for this provider
  if (user?.apiKeys?.[schemaKey] && user.apiKeys[schemaKey].trim().length > 0) {
    apiKey = user.apiKeys[schemaKey].trim();
    keySource = 'user';
    usingDefaultKey = false;
  } 
  // For OpenAI, check legacy key as well
  else if (provider === 'openai' && user?.openaiApiKey && user.openaiApiKey.trim().length > 0) {
    apiKey = user.openaiApiKey.trim();
    keySource = 'legacy';
    usingDefaultKey = false;
  } 
  // If no user key, try default key
  else if (DEFAULT_KEYS[provider] && DEFAULT_KEYS[provider].trim().length > 0) {
    apiKey = DEFAULT_KEYS[provider];
    keySource = 'system-default';
    usingDefaultKey = true;
  } 
  // If no key available for preferred model, fall back to GPT-4o
  else {
    // Notify the user that we're falling back
    notifyApiKeyStatus(userId, {
      hasKey: false,
      engine: preferredModel,
      provider,
      message: `No API key available for ${preferredModel}, falling back to gpt-4o`
    });
    
    // Reset to GPT-4o
    preferredModel = 'gpt-4o';
    
    // Try user's GPT-4o key
    if (user?.apiKeys?.gpt4o && user.apiKeys.gpt4o.trim().length > 0) {
      apiKey = user.apiKeys.gpt4o.trim();
      keySource = 'fallback-user';
      usingDefaultKey = false;
    } 
    // Try legacy key
    else if (user?.openaiApiKey && user.openaiApiKey.trim().length > 0) {
      apiKey = user.openaiApiKey.trim();
      keySource = 'fallback-legacy';
      usingDefaultKey = false;
    }
    // Try default key
    else if (DEFAULT_KEYS['openai'] && DEFAULT_KEYS['openai'].trim().length > 0) {
      apiKey = DEFAULT_KEYS['openai'];
      keySource = 'fallback-system';
      usingDefaultKey = true;
    }
    // No keys available at all
    else {
      console.error(`[OpenAIClient] No API keys available for user ${userId}`);
      throw new Error('No API keys available');
    }
  }

  // Log what we're using but mask most of the key
  const maskedKey = apiKey.length > 8 
    ? `${apiKey.substring(0, 4)}...${apiKey.substring(apiKey.length - 4)}` 
    : '[none]';
  console.log(
    `[ChatClient] Using ${preferredModel} with key ${maskedKey} for user ${userId} ` +
    `(source: ${keySource}, default: ${usingDefaultKey})`
  );
  
  // Create client with appropriate configuration and metadata
  return new OpenAI({ 
    apiKey, 
    baseURL,
    defaultQuery: { usingDefaultKey, keySource, engine: preferredModel, provider }
  });
}

/**
 * Check if a user has a valid API key for the specified engine
 * @param {string} userId - User ID
 * @param {string} engineName - Engine name (gpt-4o, qwen-2.5-vl-72b, etc.)
 * @returns {Object} - Object containing whether key exists and source
 */
async function checkEngineApiKey(userId, engineName) {
  // Validate the engine name is one we support
  if (!Object.keys(ENGINE_KEY_MAPPING).includes(engineName)) {
    console.warn(`Unsupported engine requested: ${engineName}, falling back to gpt-4o`);
    engineName = 'gpt-4o'; // Default fallback
  }
  
  // Map from engine name to API key type
  const apiKeyType = ENGINE_KEY_MAPPING[engineName];
  
  // Map from engine name to database schema key
  const engineToSchemaKey = {
    'gpt-4o': 'gpt4o',
    'qwen-2.5-vl-72b': 'qwen',
    'gemini-2.5-pro': 'gemini',
    'ui-tars': 'uitars'
  };
  
  // Get the schema key for this engine
  const schemaKey = engineToSchemaKey[engineName];
  console.log(`[API Key Check] Checking API key for engine ${engineName} using schema key ${schemaKey}`);
  
  // Default fallback keys - mapped to our standardized key types
  const DEFAULT_KEYS = {
    'openai': process.env.DEFAULT_GPT4O_KEY || '',
    'qwen': process.env.DEFAULT_OPENROUTER_KEY || '',
    'google': process.env.DEFAULT_GEMINI_KEY || '',
    'uitars': process.env.DEFAULT_UITARS_KEY || ''
  };
  
  // Fetch user's API keys
  const user = await User
    .findById(userId)
    .select('apiKeys openaiApiKey')
    .lean();

  if (!user) {
    return { 
      hasKey: DEFAULT_KEYS['openai'].length > 0, 
      keySource: 'system-default',
      usingDefault: true,
      engine: 'gpt-4o', // Always fall back to GPT-4o for missing users
      keyType: 'openai'
    };
  }

  // This is where we removed a duplicate nested function
  // The main function already does this check correctly


  // Check if user has the required key based on schema mapping
  if (user?.apiKeys?.[schemaKey] && user.apiKeys[schemaKey].trim().length > 0) {
    console.log(`[API Key Check] Found user API key for ${engineName} in schema key ${schemaKey}`);
    return { 
      hasKey: true, 
      keySource: 'user', 
      usingDefault: false, 
      engine: engineName,
      keyType: apiKeyType 
    };
  }
  
  // Special case for legacy OpenAI key
  if (apiKeyType === 'openai' && user?.openaiApiKey && user.openaiApiKey.trim().length > 0) {
    return { 
      hasKey: true, 
      keySource: 'legacy', 
      usingDefault: false, 
      engine: engineName,
      keyType: apiKeyType 
    };
  }
  
  // Check for default key
  if (DEFAULT_KEYS[apiKeyType] && DEFAULT_KEYS[apiKeyType].length > 0) {
    return { 
      hasKey: true, 
      keySource: 'system-default', 
      usingDefault: true, 
      engine: engineName,
      keyType: apiKeyType 
    };
  }
  
  // If we get here, no key was found - either user or default
  // For ui-tars, we always consider it available
  if (engineName === 'ui-tars') {
    return { 
      hasKey: true, 
      keySource: 'internal', 
      usingDefault: false, 
      engine: engineName,
      keyType: apiKeyType 
    };
  }
  
  // For any other engine, we need to fall back to GPT-4o
  return { 
    hasKey: false, 
    keySource: 'none', 
    usingDefault: false, 
    engine: engineName,
    keyType: apiKeyType,
    fallbackEngine: 'gpt-4o',
    fallbackKeyType: 'openai'
  };
}

/**
 * Notify a user about API key status
 * @param {string} userId - User ID
 * @param {Object} keyInfo - Information about the key status
 */
function notifyApiKeyStatus(userId, keyInfo) {
  // Log the API key status regardless of notification type
  if (!keyInfo.hasKey) {
    console.log(`[API Key] No API key found for ${keyInfo.engine}, notifying user`);
  } else if (keyInfo.usingDefault) {
    console.log(`[API Key] Using system default API key for ${keyInfo.engine} from source: ${keyInfo.keySource}`);
  } else if (keyInfo.keySource === 'user') {
    console.log(`[API Key] Using user's own API key for ${keyInfo.engine}`);
  }
}

/**
 * Set up environment variables for midscene based on user preferences following
 * the guidelines at https://midscenejs.com/choose-a-model.html
 * This must be called before creating any midscene agent.
 */
async function setupNexusEnvironment(userId) {
  // Default API key fallbacks from environment (for development/testing)
  const DEFAULT_GPT4O_KEY = process.env.DEFAULT_GPT4O_KEY || '';
  const DEFAULT_OPENROUTER_KEY = process.env.DEFAULT_OPENROUTER_KEY || '';
  const DEFAULT_GEMINI_KEY = process.env.DEFAULT_GEMINI_KEY || '';
  const DEFAULT_UITARS_KEY = process.env.DEFAULT_UITARS_KEY || '';

  // Fetch user and their API keys + preferences
  const user = await User
    .findById(userId)
    .select('apiKeys preferredEngine modelPreferences')
    .lean();

  if (!user) {
    console.error(`[MidsceneEnv] User ${userId} not found`);
    return false;
  }

  // Get preferred engine or default to GPT-4o
  const preferredEngine = user?.preferredEngine || 'gpt-4o';
  console.log(`[MidsceneEnv] Setting up engine: ${preferredEngine} for user ${userId}`);

  // Log the state of environment variables before resetting
  console.log(`[MidsceneEnv] BEFORE RESET - Environment variables state:`);
  console.log(`[MidsceneEnv] OPENAI_BASE_URL = ${process.env.OPENAI_BASE_URL || 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_USE_QWEN_VL = ${process.env.MIDSCENE_USE_QWEN_VL || 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_USE_GEMINI = ${process.env.MIDSCENE_USE_GEMINI || 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_USE_VLM_UI_TARS = ${process.env.MIDSCENE_USE_VLM_UI_TARS || 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_MODEL_NAME = ${process.env.MIDSCENE_MODEL_NAME || 'not set'}`);

  // Reset all environment variables to avoid conflicts
  delete process.env.OPENAI_BASE_URL;
  delete process.env.MIDSCENE_USE_QWEN_VL;
  delete process.env.MIDSCENE_USE_GEMINI;
  delete process.env.MIDSCENE_USE_VLM_UI_TARS;
  
  // Standard configuration across all models
  process.env.MIDSCENE_MAX_STEPS = '50';
  process.env.MIDSCENE_TIMEOUT = '240000'; // 4 min

  // Configure environment based on selected engine
  switch (preferredEngine) {
    case 'gpt-4o':
      // OpenAI GPT-4o configuration
      const gpt4oKey = (user?.apiKeys?.gpt4o && user.apiKeys.gpt4o.trim().length > 0)
        ? user.apiKeys.gpt4o.trim()
        : DEFAULT_GPT4O_KEY;
      
      process.env.OPENAI_API_KEY = gpt4oKey;
      process.env.MIDSCENE_MODEL_NAME = 'gpt-4o';
      // Optional custom endpoint configuration
      if (process.env.CUSTOM_OPENAI_ENDPOINT) {
        process.env.OPENAI_BASE_URL = process.env.CUSTOM_OPENAI_ENDPOINT;
      }
      
      console.log(`[MidsceneEnv] Configured GPT-4o, hasKey=${gpt4oKey.length > 0}`);
      break;

    case 'qwen-2.5-vl-72b':
      // Qwen-2.5-VL 72B Instruct configuration via OpenRouter per documentation
      // https://midscenejs.com/choose-a-model.html
      const qwenKey = (user?.apiKeys?.qwen && user.apiKeys.qwen.trim().length > 0)
        ? user.apiKeys.qwen.trim()
        : DEFAULT_OPENROUTER_KEY;
      
      // Configure Qwen via OpenRouter approach per documentation
      process.env.OPENAI_BASE_URL = 'https://openrouter.ai/api/v1';
      process.env.OPENAI_API_KEY = qwenKey;
      process.env.MIDSCENE_MODEL_NAME = 'qwen/qwen2.5-vl-72b-instruct';
      process.env.MIDSCENE_USE_QWEN_VL = '1';
      
      console.log(`[MidsceneEnv] Configured Qwen-2.5-VL via OpenRouter, hasKey=${qwenKey.length > 0}`);
      break;

    case 'gemini-2.5-pro':
      // Gemini-2.5-Pro configuration per documentation (https://midscenejs.com/choose-a-model.html)
      const geminiKey = (user?.apiKeys?.gemini && user.apiKeys.gemini.trim().length > 0)
        ? user.apiKeys.gemini.trim()
        : DEFAULT_GEMINI_KEY;
      
      // Debug check for valid Gemini API key format
      if (geminiKey.startsWith('sk-') || !geminiKey.includes('_')) {
        console.warn(`[MidsceneEnv] WARNING: Gemini API key may be in incorrect format! Google API keys typically start with 'AIza' and don't use 'sk-' prefix`);
      }
      
      // Make sure we're using the correct Google API key format
      // According to Google documentation, API keys should be passed without Bearer prefix
      const formattedGeminiKey = geminiKey;
      
      // Configure Gemini per documentation
      process.env.OPENAI_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/openai/';
      process.env.OPENAI_API_KEY = formattedGeminiKey;
      process.env.MIDSCENE_MODEL_NAME = 'gemini-2.5-pro';
      process.env.MIDSCENE_USE_GEMINI = '1';
      
      // Additional debugging info for Gemini setup
      console.log(`[MidsceneEnv] Configured Gemini-2.5-Pro, hasKey=${geminiKey.length > 0}`);
      console.log(`[MidsceneEnv] API key format check: starts with 'AIza'=${geminiKey.startsWith('AIza')}`);
      break;

    case 'ui-tars':
      // UI-TARS configuration with DOUBAO engine according to documentation
      // https://midscenejs.com/choose-a-model.html
      const uitarsKey = (user?.apiKeys?.uitars && user.apiKeys.uitars.trim().length > 0)
        ? user.apiKeys.uitars.trim()
        : DEFAULT_UITARS_KEY;
      
      // Check if the key looks like an inference access point ID
      const isInferencePoint = uitarsKey.startsWith('ep-');
      
      // UI-TARS/DOUBAO configuration
      process.env.OPENAI_BASE_URL = "https://ark.cn-beijing.volces.com/api/v3";
      process.env.OPENAI_API_KEY = uitarsKey; // API key
      process.env.MIDSCENE_MODEL_NAME = isInferencePoint ? uitarsKey : 'ui-tars-72b-sft'; // Use access point ID or default model
      process.env.MIDSCENE_USE_VLM_UI_TARS = 'DOUBAO';
      
      console.log(`[NexusEnv] Configured UI-TARS (DOUBAO), hasKey=${uitarsKey.length > 3}, using ${isInferencePoint ? 'inference point' : 'default model name'}`);
      break;

    default:
      console.error(`[NexusEnv] Unknown engine: ${preferredEngine}, falling back to GPT-4o`);
      // Fall back to GPT-4o
      const fallbackKey = (user?.apiKeys?.gpt4o && user.apiKeys.gpt4o.trim().length > 0)
        ? user.apiKeys.gpt4o.trim()
        : DEFAULT_GPT4O_KEY;
      
      process.env.OPENAI_API_KEY = fallbackKey;
      process.env.MIDSCENE_MODEL_NAME = 'gpt-4o';
      
      console.log(`[NexusEnv] Fallback to GPT-4o, hasKey=${fallbackKey.length > 0}`);
  }
  
  // Log the final state of environment variables after setup
  console.log(`[MidsceneEnv] AFTER SETUP - Final environment variables state:`);
  console.log(`[MidsceneEnv] OPENAI_BASE_URL = ${process.env.OPENAI_BASE_URL || 'not set'}`);
  console.log(`[MidsceneEnv] OPENAI_API_KEY = ${process.env.OPENAI_API_KEY ? '*****' + process.env.OPENAI_API_KEY.slice(-5) : 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_USE_QWEN_VL = ${process.env.MIDSCENE_USE_QWEN_VL || 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_USE_GEMINI = ${process.env.MIDSCENE_USE_GEMINI || 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_USE_VLM_UI_TARS = ${process.env.MIDSCENE_USE_VLM_UI_TARS || 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_MODEL_NAME = ${process.env.MIDSCENE_MODEL_NAME || 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_MAX_STEPS = ${process.env.MIDSCENE_MAX_STEPS || 'not set'}`);
  console.log(`[MidsceneEnv] MIDSCENE_TIMEOUT = ${process.env.MIDSCENE_TIMEOUT || 'not set'}`);
  
  return true;
}

/**
 * Enhanced browser action handler with comprehensive logging and obstacle management
 * @param {Object} args - Action arguments
 * @param {string} userId - User ID
 * @param {string} taskId - Task ID
 * @param {string} runId - Run ID 
 * @param {string} runDir - Run directory
 * @param {number} currentStep - Current step number
 * @param {Object} existingSession - Existing browser session
 * @returns {Object} - Result of the action
 */
async function handleBrowserAction(args, userId, taskId, runId, runDir, currentStep = 0, existingSession) {
  console.log(`[BrowserAction] Received currentStep: ${currentStep}`);
  
  // Set up environment variables for midscene based on user preferences
  await setupNexusEnvironment(userId);
  
  const { command, url: providedUrl } = args;
  let browser, agent, page, release;

  const actionLog = [];
  const logAction = (message, data = null) => {
    actionLog.push({ timestamp: new Date().toISOString(), step: currentStep, message, data: data ? JSON.stringify(data) : null });
    console.log(`[BrowserAction][Step ${currentStep}] ${message}`, data || '');
  };

  try {
    logAction(`Starting action with command: "${command}", URL: "${providedUrl || 'none provided'}"`);

    // Determine if it's a navigation command and set effective URL.
    const isNavigationCommand = command.toLowerCase().startsWith('navigate to ');
    let effectiveUrl;
    if (isNavigationCommand) {
      const navigateMatch = command.match(/navigate to (\S+)/i);
      if (navigateMatch) {
        effectiveUrl = navigateMatch[1];
        logAction(`Extracted URL from command: ${effectiveUrl}`);
      } else {
        throw new Error("Invalid navigate to command: no URL found");
      }
    } else {
      effectiveUrl = providedUrl;
    }

    // Validate URL for new tasks.
    if (!existingSession && !effectiveUrl) {
      throw new Error("URL required for new tasks");
    }

    // Override session using taskId to ensure unique session per task
    args.task_id = taskId;
    existingSession = activeBrowsers.get(taskId);

    // Browser session management.
    if (existingSession) {
      logAction("Using existing browser session");
      ({ browser, agent, page, release } = existingSession);
      
      // If the page is invalid or closed, create a new one.
      if (!page || page.isClosed()) {
        try {
          // Get a semaphore lock to prevent too many concurrent browser instances
          release = await browserSemaphore.acquire();
          
          if (existingSession) {
            browser = existingSession.browser;
            
            // Use existing page if provided, or get the first one
            page = existingSession.page || (await browser.pages())[0];
            logAction('Re-using previous browser session');
            
            // Initialize midscene agent with just the page (reads env vars internally)
            agent = new PuppeteerAgent(page);
            
            if (effectiveUrl && !isNavigationCommand) {
              logAction(`Navigating to provided URL: ${effectiveUrl}`);
              await page.goto(effectiveUrl, { timeout: 30000, waitUntil: 'networkidle2' });
            }
          } else {
            // Create new session and navigate.
            logAction(`Creating new browser session and navigating to URL: ${effectiveUrl}`);
            release = await browserSemaphore.acquire();
            logAction("Acquired browser semaphore");
            
            browser = await puppeteerExtra.launch({ 
              headless: false, 
              args: ["--no-sandbox", "--disable-setuid-sandbox", "--disable-web-security"],
              defaultViewport: { width: 1280, height: 720 }
            });
            logAction("Browser launched successfully");
            page = await browser.newPage();
            logAction("New page created");
            await page.setDefaultNavigationTimeout(300000); // 5 minutes
            
            // Set up listeners.
            page.on('console', msg => {
              debugLog(`Console: ${msg.text().substring(0, 150)}`);
            });
            page.on('pageerror', err => {
              debugLog(`Page error: ${err.message}`);
            });
            page.on('request', req => {
              if (['document', 'script', 'xhr', 'fetch'].includes(req.resourceType()) &&
                  !req.url().includes("challenges.cloudflare.com")) {
                debugLog(`Request: ${req.method()} ${req.url().substring(0, 100)}`);
              }
            });
            page.on('response', res => {
              if (['document', 'script', 'xhr', 'fetch'].includes(res.request().resourceType()) &&
                  !res.url().includes("challenges.cloudflare.com")) {
                debugLog(`Response: ${res.status()} ${res.url().substring(0, 100)}`);
              }
            });
            
            logAction(`Navigating to URL: ${effectiveUrl}`);
            await page.goto(effectiveUrl, { waitUntil: 'domcontentloaded', timeout: 300000 });
            logAction("Navigation completed successfully");
            
            // Initialize midscene agent with just the page (reads env vars internally)
            agent = new PuppeteerAgent(page);
            logAction("Nexus agent initialized");
            activeBrowsers.set(taskId, { browser, agent, page, release, closed: false, hasReleased: false });
            logAction("Browser session stored in active browsers");
          }
        } catch (error) {
          logAction(`Error creating browser session: ${error.message}`);
          throw error;
        }
      }
      
      if (!page || page.isClosed()) {
        logAction("Page is invalid or closed, creating a new one");
        page = await browser.newPage();
        await page.setViewport({ width: 1280, height: 720, deviceScaleFactor: 1 });
        agent = new PuppeteerAgent(page);
        activeBrowsers.set(taskId, { browser, agent, page, release, closed: false, hasReleased: false });
      }
    } else {
      // Create new session and navigate.
      logAction(`Creating new browser session and navigating to URL: ${effectiveUrl}`);
      release = await browserSemaphore.acquire();
      logAction("Acquired browser semaphore");
      
      browser = await puppeteerExtra.launch({ 
        headless: false, 
        args: ["--no-sandbox", "--disable-setuid-sandbox", "--disable-web-security"],
        defaultViewport: { width: 1280, height: 720 }
      });
      logAction("Browser launched successfully");
      page = await browser.newPage();
      logAction("New page created");
      await page.setDefaultNavigationTimeout(300000); // 5 minutes
      
      // Set up listeners.
      page.on('console', msg => {
        debugLog(`Console: ${msg.text().substring(0, 150)}`);
      });
      page.on('pageerror', err => {
        debugLog(`Page error: ${err.message}`);
      });
      page.on('request', req => {
        if (['document', 'script', 'xhr', 'fetch'].includes(req.resourceType()) &&
            !req.url().includes("challenges.cloudflare.com")) {
          debugLog(`Request: ${req.method()} ${req.url().substring(0, 100)}`);
        }
      });
      page.on('response', res => {
        if (['document', 'script', 'xhr', 'fetch'].includes(res.request().resourceType()) &&
            !res.url().includes("challenges.cloudflare.com")) {
          debugLog(`Response: ${res.status()} ${res.url().substring(0, 100)}`);
        }
      });
      
      logAction(`Navigating to URL: ${effectiveUrl}`);
      await page.goto(effectiveUrl, { waitUntil: 'domcontentloaded', timeout: 300000 });
      logAction("Navigation completed successfully");
      
      agent = new PuppeteerAgent(page);
      logAction("PuppeteerAgent initialized");
      activeBrowsers.set(taskId, { browser, agent, page, release, closed: false, hasReleased: false });
      logAction("Browser session stored in active browsers");
    }

    // Progress update.
    sendWebSocketUpdate(userId, { 
      event: 'stepProgress', 
      taskId, 
      stepIndex: currentStep, 
      progress: 30, 
      message: `Executing: ${command}`,
      log: actionLog
    });

    // Set viewport.
    await page.setViewport({ width: 1280, height: 720, deviceScaleFactor: 1 });
    logAction("Set viewport to 1280x720");

    // Handle page obstacles.
    logAction("Checking for page obstacles");
    const obstacleResults = await handlePageObstacles(page, agent);
    logAction("Obstacle check results", obstacleResults);

    // Execute action (only for non-navigation commands).
    logAction(`Executing action: "${command}"`);
    await agent.aiAction(command);

    logAction("Action executed successfully");

    // Check for popups.
    const popupCheck = await page.evaluate(() => {
      return {
        url: window.location.href,
        popupOpened: window.opener !== null,
        numFrames: window.frames.length,
        alerts: document.querySelectorAll('[role="alert"]').length
      };
    });
    logAction("Post-action popup check", popupCheck);

    if (popupCheck.popupOpened) {
      logAction("Popup detected - checking for new pages");
      const pages = await browser.pages();
      if (pages.length > 1) {
        logAction(`Found ${pages.length} pages, switching to newest`);
        const newPage = pages[pages.length - 1];
        if (newPage !== page) {
          page = newPage;
          agent = new PuppeteerAgent(page);
          logAction("Switched to new page and reinitialized agent");
        }
      }
    }

    // Extract rich context (extractedInfo remains separate).
    logAction("Extracting rich page context");
    const { pageContent: extractedInfo, navigableElements } = await extractRichPageContext(
      agent, 
      page, 
      command,
      "Read, scan and observe the page. Then state - What information is now visible on the page? What can be clicked or interacted with?"
    );
    logAction("Rich context extraction complete", { 
      contentLength: typeof extractedInfo === 'string' ? extractedInfo.length : 'object',
      navigableElements: navigableElements.length
    });

    // Capture screenshot.
    const screenshotFilename = `screenshot-${Date.now()}.png`;
    const screenshotPath = path.join(runDir, screenshotFilename);
    const screenshot = await page.screenshot({ encoding: 'base64' });
    fs.writeFileSync(screenshotPath, Buffer.from(screenshot, 'base64'));
    const screenshotUrl = `/nexus_run/${runId}/${screenshotFilename}`;
    logAction("Screenshot captured and saved", { path: screenshotPath });

    const currentUrl = await page.url();
    logAction(`Current URL: ${currentUrl}`);

    console.log('[Server] Preparing to send intermediateResult for taskId:', taskId);
    // Send intermediate result update to the front end.
    sendWebSocketUpdate(userId, {
      event: 'intermediateResult',
      taskId,
      result: {
        screenshotUrl,   
        currentUrl,
        extractedInfo,    // Raw extracted info.
        navigableElements
      }
    });
    console.log('[Server] Sent intermediateResult for taskId:', taskId);

    // Final progress update.
    sendWebSocketUpdate(userId, { 
      event: 'stepProgress', 
      taskId, 
      stepIndex: currentStep, 
      progress: 100, 
      message: 'Action completed',
      log: actionLog
    });

    // Trim action log before returning.
    const trimmedActionLog = actionLog.map(entry => {
      const truncatedMessage = entry.message.length > 700 
        ? entry.message.substring(0, 700) + '...'
        : entry.message;
      return { ...entry, message: truncatedMessage };
    });

    // Create an active browser session to be reused
    const browserSession = { browser, agent, page, release, closed: false, hasReleased: false };
    
    // For efficiency, update the session in the active browsers map as well
    activeBrowsers.set(taskId, browserSession);
    
    // Return full results - now including browserSession for reuse
    // Note: "state" contains only the assertion result.
    return {
      success: true,
      error: null,
      task_id: taskId,
      closed: false,
      currentUrl,
      stepIndex: currentStep,
      actionOutput: `Completed: ${command}`,
      pageTitle: await page.title(),
      extractedInfo,        // Full extraction data.
      navigableElements,      // Navigable elements.
      actionLog: trimmedActionLog,
      screenshotPath: screenshotUrl,
      // Return the browser session so it can be maintained across steps
      browserSession,
      state: {
        assertion: extractedInfo && extractedInfo.pageContent 
        ? extractedInfo.pageContent 
        : 'No content extracted'
      }
    };

  } catch (error) {
    logAction(`Error in browser action: ${error.message}`, { stack: error.stack });
    if (typeof release === 'function') release();

    // Trim action log on error.
    const trimmedActionLog = actionLog.map(entry => {
      const shortMsg = entry.message.length > 150 
        ? entry.message.substring(0, 150) + '...'
        : entry.message;
      return { ...entry, message: shortMsg };
    });

    return {
      success: false,
      error: error.message,
      actionLog: trimmedActionLog,
      currentUrl: page ? await page.url() : null,
      task_id: taskId,
      stepIndex: currentStep
    };
  }
}

/**
 * Enhanced browser query handler with improved logging, obstacle management,
 * and inclusion of a "state" property that holds a concise assertion of the page.
 * @param {Object} args - Query arguments
 * @param {string} userId - User ID
 * @param {string} taskId - Task ID
 * @param {string} runId - Run ID 
 * @param {string} runDir - Run directory
 * @param {number} currentStep - Current step number
 * @param {Object} existingSession - Existing browser session
 * @returns {Object} - Result of the query including state.
 */
async function handleBrowserQuery(args, userId, taskId, runId, runDir, currentStep = 0, existingSession) {
  console.log(`[BrowserQuery] Received currentStep: ${currentStep}`);
  // Set up environment variables for midscene based on user preferences
  await setupNexusEnvironment(userId);
  const { query, url: providedUrl } = args;
  let browser, agent, page, release;

  const actionLog = [];
  const logQuery = (message, data = null) => {
    actionLog.push({ timestamp: new Date().toISOString(), step: currentStep, message, data: data ? JSON.stringify(data) : null });
    console.log(`[BrowserQuery][Step ${currentStep}] ${message}`);
  };

  await updateTaskInDatabase(taskId, {
    status: 'processing',
    progress: 50,
    lastAction: query
  });

  try {
    logQuery(`Starting query: "${query}"`);
    
    const taskKey = taskId;

    if (existingSession) {
      logQuery("Using existing browser session");
      ({ browser, agent, page, release } = existingSession);
      if (!page || page.isClosed()) {
        logQuery("Page is invalid or closed, creating a new one");
        page = await browser.newPage();
        await page.setViewport({ width: 1280, height: 720, deviceScaleFactor: 1 });
        agent = new PuppeteerAgent(page);
        activeBrowsers.set(taskId, { browser, agent, page, release, closed: false, hasReleased: false });
      }
    } else if (taskKey && activeBrowsers.has(taskKey)) {
      const session = activeBrowsers.get(taskKey);
      if (!session || !session.browser) {
        logQuery("Browser session not valid, creating a new one.");
        browser = await puppeteerExtra.launch({ 
          headless: false, 
          args: ["--no-sandbox", "--disable-setuid-sandbox", "--disable-web-security"],
          defaultViewport: { width: 1280, height: 720 }
        });
        logQuery("Browser launched successfully");
        page = await browser.newPage();
        logQuery("New page created");
        await page.setDefaultNavigationTimeout(60000); // 60 seconds
        agent = new PuppeteerAgent(page);
        release = null;
        activeBrowsers.set(taskKey, { browser, agent, page, release, closed: false, hasReleased: false });
      } else {
        ({ browser, agent, page, release } = session);
      }
    } else {
      if (!providedUrl) throw new Error("URL required for new tasks");
      logQuery(`Creating new browser session for URL: ${providedUrl}`);
      release = await browserSemaphore.acquire();
      logQuery("Acquired browser semaphore");
      
      browser = await puppeteerExtra.launch({ 
        headless: false,
        args: ["--no-sandbox", "--disable-setuid-sandbox", "--disable-web-security"],
        defaultViewport: { width: 1280, height: 720 }
      });
      logQuery("Browser launched successfully");
      page = await browser.newPage();
      logQuery("New page created");
      await page.setDefaultNavigationTimeout(60000); // 60 seconds
      // Set up event listeners.
      page.on('console', msg => {
        debugLog(`Console: ${msg.text().substring(0, 150)}`);
      });
      page.on('pageerror', err => {
        debugLog(`Page error: ${err.message}`);
      });
      page.on('request', req => {
        if (['document', 'script', 'xhr', 'fetch'].includes(req.resourceType()) &&
            !req.url().includes("challenges.cloudflare.com")) {
          debugLog(`Request: ${req.method()} ${req.url().substring(0, 100)}`);
        }
      });
      page.on('response', res => {
        if (['document', 'script', 'xhr', 'fetch'].includes(res.request().resourceType()) &&
            !res.url().includes("challenges.cloudflare.com")) {
          debugLog(`Response: ${res.status()} ${res.url().substring(0, 100)}`);
        }
      });
      
      logQuery(`Navigating to URL: ${providedUrl}`);
      await page.goto(providedUrl, { waitUntil: 'domcontentloaded', timeout: 60000 });
      logQuery("Navigation completed successfully");
      
      // Initialize midscene agent with just the page (reads env vars internally)
      agent = new PuppeteerAgent(page);
      logQuery("PuppeteerAgent initialized");
      activeBrowsers.set(taskKey, { browser, agent, page, release, closed: false, hasReleased: false });
      logQuery("Browser session stored in active browsers");
    }

    sendWebSocketUpdate(userId, { 
      event: 'stepProgress', 
      taskId, 
      stepIndex: currentStep, 
      progress: 30, 
      message: `Querying: ${query}`,
      log: actionLog
    });
    
    await page.setViewport({ width: 1280, height: 720, deviceScaleFactor: 1 });
    logQuery("Set viewport to 1280x720");
    
    logQuery(`Executing query: "${query}"`);
    // Perform extraction only once.
    const { pageContent: extractedInfo, navigableElements } = await extractRichPageContext(
      agent, 
      page, 
      "read, scan, extract, and observe",
      query
    );
    logQuery("Query executed successfully");
    
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const stateCheck = await page.evaluate(() => ({
      url: window.location.href,
      popupOpened: window.opener !== null,
      numFrames: window.frames.length,
      alerts: document.querySelectorAll('[role="alert"]').length
    }));
    logQuery("Post-query state check", stateCheck);
    
    if (stateCheck.popupOpened) {
      logQuery("Popup detected - checking for new pages");
      const pages = await browser.pages();
      if (pages.length > 1) {
        logQuery(`Found ${pages.length} pages, switching to newest`);
        const newPage = pages[pages.length - 1];
        if (newPage !== page) {
          page = newPage;
          agent = new PuppeteerAgent(page);
          logQuery("Switched to new page and reinitialized agent");
        }
      }
    }
    
    const screenshot = await page.screenshot({ encoding: 'base64' });
    const screenshotFilename = `screenshot-${Date.now()}.png`;
    const screenshotPath = path.join(runDir, screenshotFilename);
    fs.writeFileSync(screenshotPath, Buffer.from(screenshot, 'base64'));
    const screenshotUrl = `/nexus_run/${runId}/${screenshotFilename}`;
    logQuery("Screenshot captured and saved", { path: screenshotPath });

    const currentUrl = await page.url();
    logQuery(`Current URL: ${currentUrl}`);
    
    sendWebSocketUpdate(userId, {
      event: 'intermediateResult',
      taskId,
      result: {
        screenshotUrl,
        currentUrl,
        extractedInfo: cleanForPrompt(extractedInfo),
        navigableElements: Array.isArray(navigableElements) 
          ? navigableElements.map(el => cleanForPrompt(el))
          : cleanForPrompt(navigableElements)
      }
    });

    sendWebSocketUpdate(userId, { 
      event: 'stepProgress', 
      taskId, 
      stepIndex: currentStep, 
      progress: 100, 
      message: 'Query completed',
      log: actionLog
    });

    const trimmedActionLog = actionLog.map(entry => {
      const truncatedMessage = entry.message.length > 700 
        ? entry.message.substring(0, 700) + '...'
        : entry.message;
      return { ...entry, message: truncatedMessage };
    });

    const assertion = 'After execution, this is whats now visible: ' + extractedInfo.substring(0, 150) + '...';
    logQuery("Assertion for query completed", { assertion });

    // Create a browser session object for reuse
    const browserSession = { browser, agent, page, release, closed: false, hasReleased: false };
    
    // Update the active browsers map
    activeBrowsers.set(taskId, browserSession);
    
    // Return full results with state holding the assertion and browser session for reuse
    return {
      success: true,
      error: null,
      task_id: taskId,
      closed: false,
      currentUrl,
      stepIndex: currentStep,
      actionOutput: `Completed: ${query}`,
      pageTitle: await page.title(),
      extractedInfo,
      navigableElements,
      actionLog: trimmedActionLog,
      screenshotPath: screenshotUrl,
      // Include browser session for reuse across steps
      browserSession,
      state: {
        assertion // The state now holds the concise summary of the page.
      }
    };
  } catch (error) {
    logQuery(`Error in browser query: ${error.message}`, { stack: error.stack });
    if (typeof release === 'function') release();

    const trimmedActionLog = actionLog.map(entry => {
      const shortMsg = entry.message.length > 150 
        ? entry.message.substring(0, 150) + '...'
        : entry.message;
      return { ...entry, message: shortMsg };
    });

    return {
      success: false,
      error: error.message,
      actionLog: trimmedActionLog,
      currentUrl: page ? await page.url() : null,
      task_id: taskId,
      stepIndex: currentStep
    };
  }
}

// Global handler for unhandled promise rejections, particularly for Puppeteer
process.on('unhandledRejection', (reason, promise) => {
  // Only log detailed info for non-puppeteer errors to avoid console spam
  if (reason && reason.message && reason.message.includes('Request is already handled')) {
    // This is a known Puppeteer issue when request interception has race conditions
    // Just log a brief message and continue - it doesn't affect functionality
    console.log('[Puppeteer] Ignoring known issue: Request is already handled');
  } else {
    // For other types of unhandled rejections, log full details
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  }
  // Don't crash the process, allowing the application to continue
});

/**
 * Helper function to conditionally log debug messages.
 */
function debugLog(msg, data = null) {
  if (process.env.DEBUG_MODE === 'true') {
    console.log(`[DEBUG] ${msg}`, data || '');
  }
};

// ===========================
// MAIN CHAT LOGIC & route entry
// ===========================

// Token usage tracking is implemented further down in the file

/**
 * Quick Classifier that calls your LLM to see if the user wants â€œchatâ€ or â€œtaskâ€.
 * 
 */
async function openaiClassifyPrompt(prompt, userId) {
  // Declare client outside try block so it's available in the catch block
  let client;
  
  try {
    // IMPORTANT: Always use chat-specific model preference for classification
    // This ensures we're not affected by browser automation engine selection
    client = await getUserOpenAiClient(userId, true); // true = for chat purpose
    
    // Always use a small model for classification to save tokens
    const resp = await client.chat.completions.create({
      model: 'gpt-4o-mini', 
      messages: [
        { role: 'system', content: 'You classify user messages as "task" or "chat". If tone is instruction classify as task. If tone is neutral or comment or question classify as chat. Respond ONLY with "task" or "chat".' },
        { role: 'user',   content: prompt }
      ],
      temperature: 0,
      max_tokens: 5
    });
    
    // Estimate token usage (approximate calculation)
    // System prompt (~20 tokens) + user prompt (~tokens based on length) + response (1-5 tokens)
    const promptTokens = Math.ceil(prompt.length / 4); // Rough estimate: 4 chars per token
    const totalTokens = 20 + promptTokens + 5;
    
    // Track token usage
    await trackTokenUsage(userId, totalTokens, "gpt-4o-mini");
    
    const c = resp.choices?.[0]?.message?.content?.toLowerCase() || '';
    return c.includes('task') ? 'task' : 'chat';
  } catch (err) {
    // Handle authentication errors specially
    if (err.status === 401 || err.message?.includes('auth')) {
      const keyType = client?.defaultQuery?.keyType || 'unknown';
      console.error(`Authentication error with ${keyType} API key during classification: ${err.message}`);
      return { error: 'auth', message: `Authentication error with your ${keyType} API key. Please check your settings.` };
    }
    // Handle rate limit errors specifically
    else if (err.status === 429 || err.code === 'insufficient_quota' || err.message?.includes('exceeded your current quota')) {
      const provider = client?.defaultQuery?.provider || 'OpenAI';
      const errorMessage = `Rate limit exceeded with ${provider} API: ${err.message}`;
      console.error('Error classifying prompt:', err);
      return { 
        error: 'rate_limit', 
        message: `ðŸš« API Quota Exceeded: You've exceeded your ${provider} API quota. Please check your billing details or switch models.` 
      };
    } else {
      console.error('Error classifying prompt:', err);
      return { error: 'general', message: `Error: ${err.message}` };
    }
    // If we return with no return statement, default to chat
  }
}

/**
 * Refactored processTask function using the grand plan approach
 * @param {string} userId - User ID
 * @param {string} userEmail - User email
 * @param {string} taskId - Task ID
 * @param {string} runId - Run ID 
 * @param {string} runDir - Run directory
 * @param {string} prompt - Task prompt
 * @param {string} url - Starting URL
 * @param {string} engine - Engine to use for this task (optional)
 */
// Import YAML map processing utilities
import { processYamlMapTask, extractYamlMapIdFromPrompt } from './src/utils/yamlProcessor.js';

async function processTask(userId, userEmail, taskId, runId, runDir, prompt, url, engine) {
  // --- Unified message persistence: save user command as message ---
  await new Message({
    userId,
    role: 'user',
    type: 'command',
    content: prompt,
    taskId,
    timestamp: new Date()
  }).save();
  console.log(`[ProcessTask] Starting ${taskId}: "${prompt}"`);
  
  // Check if the prompt contains a YAML map reference or if it was attached via the UI
  let yamlMapId = extractYamlMapIdFromPrompt(prompt);
  
  // Also check if the prompt contains a direct YAML map reference that might be formatted differently
  if (!yamlMapId) {
    // Alternative pattern check: Look for "yaml map: ID" pattern
    const yamlMapPattern = /yaml\s+map:?\s+([a-zA-Z0-9]+)/i;
    const match = prompt.match(yamlMapPattern);
    if (match && match[1]) {
      yamlMapId = match[1];
      console.log(`[ProcessTask] Detected YAML map ID from alternative pattern: ${yamlMapId}`);
    }
  }
  
  if (yamlMapId) {
    console.log(`[ProcessTask] Detected YAML map reference: ${yamlMapId}`);
    // Update task with yamlMapId to ensure it's tracked properly
    await Task.updateOne({ _id: taskId }, { $set: { yamlMapId, status: 'executing' } });
    try {
      // Create a minimal tasksStore object if not available
      const fallbackTasksStore = {
        addStepLog: (taskId, logEntry) => {
          console.log(`[YAML] Task ${taskId} log:`, logEntry);
          return null; // No-op implementation
        }
      };
      
      // Get the user's preferred engine for browser automation
      const user = await User.findById(userId).select('preferredEngine modelPreferences').lean();
      // For browser automation: first check browser model preference, then fall back to general preferred engine, and finally default to gpt-4o
      const browserEngine = user?.modelPreferences?.browser || user?.preferredEngine || 'gpt-4o';
      console.log(`[ProcessTask] Using browser engine for YAML execution: ${browserEngine}`);
      
      // Handle YAML map execution - DIRECT EXECUTION PATH (bypassing step planning)
      return await processYamlMapTask({
        userId,
        userEmail,
        taskId,
        runId,
        runDir,
        yamlMapId,
        url,
        engine: browserEngine, // Pass the determined browser engine
        tasksStore: fallbackTasksStore, // Use our fallback implementation
        sendWebSocketUpdate,
        setupNexusEnvironment,
        updateTaskInDatabase: async (taskId, updateData) => {
          return await Task.updateOne({ _id: taskId }, { $set: updateData });
        }
      });
    } catch (error) {
      console.error(`[ProcessTask] Error executing YAML map ${yamlMapId}:`, error);
      throw error;
    }
  }
  // Fetch the user's execution mode preference, browser model preference, and validate engine
  const user = await User.findById(userId).select('executionMode preferredEngine modelPreferences').lean();
  const executionMode = user?.executionMode || 'step-planning';
  
  // First check for explicitly requested engine in the function call
  // Then check user's browser model preference
  // Then fall back to user's general preferred engine
  // Finally default to gpt-4o
  const browserPreference = user?.modelPreferences?.browser;
  const engineToUse = engine || browserPreference || user?.preferredEngine || 'gpt-4o';
  
  console.log(`[ProcessTask] Engine selection for browser automation: ${engineToUse} (from: ${engine ? 'explicit' : browserPreference ? 'browser preference' : user?.preferredEngine ? 'preferred engine' : 'default'})`);
  
  // Check if the engine is valid and the user has access to it
  const keyInfo = await checkEngineApiKey(userId, engineToUse);
  if (!keyInfo.hasKey) {
    console.error(`[ProcessTask] No API key available for ${engineToUse}, falling back to GPT-4o`);
    // Fall back to GPT-4o if no key is available for the specified engine
    // This is a safety fallback that should never happen if the API endpoints are working correctly
    const gpt4oKeyInfo = await checkEngineApiKey(userId, 'gpt-4o');
    if (!gpt4oKeyInfo.hasKey) {
      throw new Error(`No API key available for any engine`);
    }
    // Use GPT-4o as the fallback engine
    // Note: We don't have access to req.session here, but that's fine since we're directly using GPT-4o now
    // Notify the user about the fallback
    notifyApiKeyStatus(userId, {
      hasKey: true,
      engine: 'gpt-4o',
      usingDefault: true,
      keySource: 'fallback-system',
      message: `No API key available for ${engineToUse}, falling back to GPT-4o`
    });
  } else if (keyInfo.usingDefault) {
    // Notify the user that we're using a default key
    notifyApiKeyStatus(userId, keyInfo);
  }
  
  console.log(`[ProcessTask] Using engine: ${engineToUse} with execution mode: ${executionMode} for task ${taskId}`);

  const plan = new TaskPlan(userId, taskId, prompt, url, runDir, runId);
  plan.log(`Plan created with engine: ${engineToUse} and execution mode: ${executionMode}`);

  // Clear any queued old messages for this user to avoid stale deliveries
  unsentMessages.delete(userId);

  try {
    await Task.updateOne({ _id: taskId }, { status:'processing', progress:5 });
    sendWebSocketUpdate(userId, { event:'taskStart', taskId, prompt, url });
    plan.log("taskStart â†’ frontend");

    let taskCompleted = false, consecutiveFailures = 0;

    while (!taskCompleted && plan.currentStepIndex < plan.maxSteps - 1) {
      const systemPrompt = plan.generateSystemPrompt();
      plan.log("SYSTEM PROMPT generated");
      
      let messages = [
        { role: "system", content: systemPrompt },
        { role: "user", content: prompt }
      ];
      
      if (plan.steps.length > 0) {
        plan.steps.slice(-3).forEach(step => {
          if (step.result) {
            const toolCallId = `call_${step.index}`;
            messages.push({
              role: "assistant",
              content: null,
              tool_calls: [
                {
                  id: toolCallId,
                  type: "function",
                  function: {
                    name: step.type === 'action' ? 'browser_action' : 'browser_query',
                    arguments: JSON.stringify({
                      [step.type === 'action' ? 'command' : 'query']: step.instruction,
                      task_id: taskId,
                      url: plan.currentUrl
                    })
                  }
                }
              ]
            });
            messages.push({
              role: "tool",
              tool_call_id: toolCallId,
              name: step.type === 'action' ? 'browser_action' : 'browser_query',
              content: JSON.stringify({
                success: step.result.success,
                currentUrl: step.result.currentUrl,
                error: step.result.error,
                extractedInfo: typeof step.result.extractedInfo === 'string'
                  ? step.result.extractedInfo.substring(0, 1500) + '...'
                  : "No extraction",
                navigableElements: Array.isArray(step.result.navigableElements) 
                  ? step.result.navigableElements.slice(0, 30) 
                  : []
              })
            });
          }
        });
      }
      
      if (plan.currentState && plan.currentState.pageDescription) {
        let descriptionText = (typeof plan.currentState.pageDescription === 'string')
          ? plan.currentState.pageDescription.substring(0, 300) + '...'
          : JSON.stringify(plan.currentState.pageDescription).substring(0, 300) + '...';
        messages.push({
          role: "system",
          content: `Current page state: ${descriptionText}`
        });
      }
      
      // Extracted data logged thorough
      if (plan.steps.length > 0) {
        const lastStep = plan.steps[plan.steps.length - 1];
        plan.log("Using extraction from last step", {
          extractedInfo: cleanForPrompt(lastStep.result?.extractedInfo),
          navigableElements: lastStep.result?.navigableElements
        });
      } else {
        plan.log("No intermediate extraction data available.");
      }
      
      // Log which execution mode is being used
      plan.log(`Using execution mode: ${executionMode} for AI request`);
      
      plan.log("Sending function call request to AI", { messages });
      
      // Configure the AI request based on execution mode
      const streamConfig = {
        model: "gpt-4o-mini",
        messages,
        stream: true,
        temperature: 0.3,
        max_tokens: 700,
        tools: [
          {
            type: "function",
            function: {
              name: "browser_action",
              description: "Executes a browser action by specifying a complete natural language instruction, e.g., 'navigate to https://example.com', 'type Sony Wireless headphones into the search bar', or 'click the search button'. The 'command' parameter must include both the verb and the target details.",
              parameters: {
                type: "object",
                properties: {
                  command: { type: "string", description: "Natural language instruction for the browser action, including verb and target" },
                  url: { type: "string", description: "The page URL on which to perform the action" },
                  task_id: { type: "string", description: "Identifier for the current task" }
                },
                required: ["command"]
              }
            }
          },
          {
            type: "function",
            function: {
              name: "browser_query",
              description: "Extracts information from the webpage by performing the specified query, e.g., 'list all clickable elements on the page'. The 'query' parameter must clearly state what to extract.",
              parameters: {
                type: "object",
                properties: {
                  query: { type: "string", description: "Natural language query describing what information to extract from the page" },
                  url: { type: "string", description: "The page URL from which to extract information" },
                  task_id: { type: "string", description: "Identifier for the current task" }
                },
                required: ["query"]
              }
            }
          },
          {
            type: "function",
            function: {
              name: "task_complete",
              description: "Signals that the task is complete with a final summary.",
              parameters: {
                type: "object",
                properties: { summary: { type: "string" } },
                required: []
              }
            }
          }
        ],
        tool_choice: "auto"
      };

      // Special handling for UI-TARS and action-planning mode
      const isUiTars = engineToUse === 'ui-tars';
      const isActionPlanning = executionMode === 'action-planning';
      
      if (isUiTars || isActionPlanning) {
        // For UI-TARS or action-planning mode, modify the system prompt to emphasize end-to-end execution
        messages[0].content += "\n\nIMPORTANT: This task will be executed as a DIRECT AUTOMATION INSTRUCTION. " + 
                              "Do not decompose the task into individual steps or attempt to plan a sequence of actions. " + 
                              "Instead, interpret the command as a single, unified task description for the automation system to execute. " + 
                              "Your response should include a clear, comprehensive description of the end goal for the automation tool.";
        
        // Add specialized behavior based on which condition triggered this mode
        if (isUiTars) {
          messages[0].content += "\n\nThis is running on UI-TARS, which has enhanced web automation capabilities. " + 
                                "Focus on the high-level goal rather than specific steps.";
        }
        
        if (isActionPlanning) {
          messages[0].content += "\n\nAction planning mode is enabled. Provide a complete sequence of actions as a single plan. " + 
                                "Think about the full workflow and optimize for efficiency with minimal back-and-forth.";
          
          // Increase temperature for more exploration in action planning mode
          streamConfig.temperature = 0.5;
        }
        
        // Add a user message specifically asking for a direct execution approach
        messages.push({
          role: "user",
          content: "Please treat my request as a direct automation instruction rather than breaking it down into steps. Provide a clear description of what should be accomplished."
        });
      }
      
      // Use the appropriate client based on the selected engine
      let stream;
      
      // Note: We don't need to call setupNexusEnvironment here since it's already called
      // in the lower-level functions (handleBrowserAction and handleBrowserQuery)
      // This avoids redundancy and potential issues with multiple environment setups
      
      // Get a chat client for the orchestration/planning part
      // This client is only used for the planning conversations, not the actual browser automation
      const client = await getUserOpenAiClient(userId);
      
      if (!client) {
        throw new Error(`No chat client available for user ${userId}`);
      }
      
      // Log the model being used for task planning
      const chatModel = client.defaultQuery?.engine || 'gpt-4o';
      plan.log(`Using chat model ${chatModel} for task planning/orchestration`);
      
      stream = await client.chat.completions.create(streamConfig);
      
      let currentFunctionCall = null;
      let accumulatedArgs = '';
      let functionCallReceived = false;
      let thoughtBuffer = '';
      
      for await (const chunk of stream) {
        const delta = chunk.choices[0]?.delta;
        
        if (delta?.content) {
          thoughtBuffer += delta.content;
          sendWebSocketUpdate(userId, { event: 'thoughtUpdate', taskId, thought: delta.content });
        }
        
        if (delta?.tool_calls) {
          for (const toolCallDelta of delta.tool_calls) {
            if (toolCallDelta.index === 0) {
              if (toolCallDelta.function.name && !currentFunctionCall) {
                currentFunctionCall = { name: toolCallDelta.function.name };
                accumulatedArgs = '';
                if (thoughtBuffer) {
                  sendWebSocketUpdate(userId, { event: 'thoughtComplete', taskId, thought: thoughtBuffer });
                  thoughtBuffer = '';
                }
                plan.log(`New tool call started: ${currentFunctionCall.name}`);
              }
              if (toolCallDelta.function.arguments) {
                accumulatedArgs += toolCallDelta.function.arguments;
                sendWebSocketUpdate(userId, {
                  event: 'functionCallPartial',
                  taskId,
                  functionName: currentFunctionCall?.name,
                  partialArgs: accumulatedArgs
                });
                try {
                  const parsedArgs = JSON.parse(accumulatedArgs);
                  plan.log("Complete tool call received", { function: currentFunctionCall.name, args: parsedArgs });
                  parsedArgs.task_id = taskId;
                  parsedArgs.url = parsedArgs.url || url || plan.currentUrl;
                  if (currentFunctionCall.name === "browser_action") {
                    const step = plan.createStep('action', parsedArgs.command, parsedArgs);
                    const result = await step.execute(plan);
                    await addIntermediateResult(userId, taskId, result);
                    consecutiveFailures = result.success ? 0 : consecutiveFailures + 1;
                    if (consecutiveFailures >= 3) {
                      plan.log("Triggering recovery due to consecutive failures");
                      const recoveryStep = plan.createStep('query', 'Suggest a new approach to achieve the Main Task', {
                        query: 'Suggest a new approach to achieve the Main Task',
                        task_id: taskId,
                        url: plan.currentUrl
                      });
                      await recoveryStep.execute(plan);
                      consecutiveFailures = 0;
                    }
                    functionCallReceived = true;
                    break;
                  } else if (currentFunctionCall.name === "browser_query") {
                    const step = plan.createStep('query', parsedArgs.query, parsedArgs);
                    const result = await step.execute(plan);
                    await addIntermediateResult(userId, taskId, result);
                    consecutiveFailures = 0;
                    functionCallReceived = true;
                    
                    // In action-planning mode, we might want to automatically follow up with actions
                    // based on the query results without requiring additional back-and-forth
                    if (executionMode === 'action-planning' && result.success) {
                      plan.log("Action-planning mode: analyzing query results for potential follow-up actions");
                    }
                    
                    break;
                  } else if (currentFunctionCall.name === "task_complete") {
                    const summary = parsedArgs.summary || `Task completed: ${prompt}`;
                    plan.markCompleted(summary);
                    const finalResult = await processTaskCompletion(
                      userId,
                      taskId,
                      plan.steps.map(step => step.result || { success: false }),
                      prompt,
                      runDir,
                      runId
                    );
                    const finalExtracted = (finalResult.raw && finalResult.raw.pageText && 
                                            cleanForPrompt(finalResult.raw.pageText).length > 0)
                      ? cleanForPrompt(finalResult.raw.pageText)
                      : (finalResult.aiPrepared && finalResult.aiPrepared.summary && 
                         cleanForPrompt(finalResult.aiPrepared.summary).length > 0)
                        ? cleanForPrompt(finalResult.aiPrepared.summary)
                        : `Task completed: ${prompt}`;
                    // Only store essential information needed by history.js
                    // Avoid storing large data objects or duplicate information
                    const cleanedFinal = {
                      success: finalResult.success,
                      // Store only the final URL, not the full page content
                      currentUrl: finalResult.raw?.url || finalResult.currentUrl,
                      // Only store a truncated version of extracted info (for display purposes)
                      summaryText: finalExtracted.length > 250 ? finalExtracted.substring(0, 250) + '...' : finalExtracted,
                      // Store just the screenshot URL, not the actual image data
                      screenshotUrl: finalResult.screenshot || finalResult.screenshotPath,
                      // Store the primary report URL and only essential alternatives
                      primaryReportUrl: finalResult.reportUrl || null,
                      landingReportUrl: finalResult.landingReportUrl || null,
                      nexusReportUrl: finalResult.nexusReportUrl || null,
                      // Always include timestamp for sorting
                      timestamp: new Date()
                    };
                    
                    // Log that we're saving essential task data
                    console.log(`[ProcessTask] Saving optimized task data for ${taskId}:`, {
                      success: cleanedFinal.success,
                      primaryReportUrl: cleanedFinal.primaryReportUrl,
                      landingReportUrl: cleanedFinal.landingReportUrl,
                      nexusReportUrl: cleanedFinal.nexusReportUrl,
                      summaryLength: cleanedFinal.summaryText?.length || 0
                    });

                    await Task.updateOne(
                      { _id: taskId },
                      { 
                        $set: { 
                          status: 'completed', 
                          progress: 100, 
                          result: cleanedFinal, 
                          endTime: new Date(),
                          summary: summary, // Save the summary provided by task_complete
                          completionReason: 'explicit' // Add completion reason to differentiate from max_steps
                        } 
                      }
                    );

                    let taskChatHistory = await ChatHistory.findOne({ userId });
                    if (!taskChatHistory) {
                      taskChatHistory = new ChatHistory({ userId, messages: [] });
                    }
                    // Store raw URLs in a clean format for better frontend rendering
                    const reportUrls = [];
                    
                    // Process each URL to make sure they're absolute (full URLs)
                    if (finalResult.landingReportUrl) {
                      // Convert relative URLs to absolute
                      const fullLandingUrl = finalResult.landingReportUrl.startsWith('/') ? 
                        (process.env.BASE_URL || `http://${req.headers.host}`) + finalResult.landingReportUrl : finalResult.landingReportUrl;
                      reportUrls.push({
                        type: 'landing',
                        label: 'Landing Report',
                        url: fullLandingUrl
                      });
                    }
                    
                    if (finalResult.nexusReportUrl) {
                      // Convert relative URLs to absolute
                      const fullNexusUrl = finalResult.nexusReportUrl.startsWith('/') ? 
                        (process.env.BASE_URL || `http://${req.headers.host}`) + finalResult.nexusReportUrl : finalResult.nexusReportUrl;
                      reportUrls.push({
                        type: 'nexus',
                        label: 'Analysis Report',
                        url: fullNexusUrl
                      });
                    }
                    
                    if (finalResult.errorReportUrl) {
                      // Convert relative URLs to absolute
                      const fullErrorUrl = finalResult.errorReportUrl.startsWith('/') ? 
                        (process.env.BASE_URL || `http://${req.headers.host}`) + finalResult.errorReportUrl : finalResult.errorReportUrl;
                      reportUrls.push({
                        type: 'error',
                        label: 'Error Report',
                        url: fullErrorUrl
                      });
                    }
                    
                    // Keep message content clean - we'll add the URLs to metadata instead
                    const contentWithLinks = finalExtracted;
                    
                    // Add explicit success completion message to chat history with completion reason
                    taskChatHistory.messages.push({
                      role: 'assistant',
                      content: contentWithLinks,
                      timestamp: new Date(),
                      hasReportLinks: reportUrls.length > 0,
                      reportUrls: reportUrls,
                      meta: {
                        completionReason: 'explicit',
                        summary: summary
                      }
                    });
                    await taskChatHistory.save();

                    // Log that we're saving a successful completion message
                    plan.log(`Saving successful task completion message to ChatHistory and Messages: "${summary}"`);
                    
                    // Create message with the clean content, completion reason and structured URL metadata
                    await Message.create({
                      userId,
                      role: 'assistant',
                      type: 'command',
                      content: contentWithLinks, // Clean content without embedded HTML links
                      taskId,
                      timestamp: new Date(),
                      hasReportLinks: reportUrls.length > 0,
                      reportUrls: reportUrls, // Store the structured report URLs array
                      meta: {
                        completionReason: 'explicit', // Track that this was an explicit completion
                        summary: finalResult.aiPrepared.summary,
                        // Also include raw URLs for backward compatibility
                        nexusReportUrl: finalResult.nexusReportUrl,
                        landingReportUrl: finalResult.landingReportUrl,
                        reportUrl: finalResult.reportUrl,
                        errorReportUrl: finalResult.errorReportUrl
                      }
                    });
                    
                    // Set task completed flag and also set a clear signal to terminate the execution loop
                    taskCompleted = true;
                    functionCallReceived = true; // Ensure we don't try to create a new recovery step
                    
                    // Initialize the exitPlanExecution flag if it doesn't exist
                    if (!plan.hasOwnProperty('exitPlanExecution')) {
                      Object.defineProperty(plan, 'exitPlanExecution', {
                        value: false,
                        writable: true,
                        enumerable: true
                      });
                    }
                    
                    plan.exitPlanExecution = true; // Add a flag to the plan to exit cleanly
                    
                    // Log clear completion message
                    plan.log(`Task execution completed successfully. Terminating task execution loop.`);
                    
                    // Break out of the switch statement
                    break;
                  }
                } catch (e) {
                  // Continue accumulating if JSON is incomplete
                }
              }
            }
          }
        }}
      
        if (thoughtBuffer) {
          sendWebSocketUpdate(userId, { event: 'thoughtComplete', taskId, thought: thoughtBuffer });
          thoughtBuffer = "";
        }
      
        // Check if task has been explicitly completed or if the plan execution should exit
        if (taskCompleted || plan.exitPlanExecution) {
          plan.log(`Task completed after ${plan.currentStepIndex + 1} steps. Exiting execution loop.`);
          // Exit the main execution loop
          break;
        }
      
        // Only create recovery step if no function call was received and the task is not completed
        if (!functionCallReceived && !taskCompleted) {
          plan.log(`No tool call received for step ${plan.currentStepIndex + 1}`);
          const recoveryStep = plan.createStep('query', 'Describe the current page state and available actions', {
            query: 'Describe the current page state and available actions',
            task_id: taskId,
            url: plan.currentUrl
          });
          await recoveryStep.execute(plan);
          consecutiveFailures = 0;
        }
      
        const progress = Math.min(95, Math.floor((plan.currentStepIndex + 1) / plan.maxSteps * 100));
        await Task.updateOne(
          { _id: taskId },
          { $set: { status: 'running', progress, currentStepIndex: plan.currentStepIndex, currentUrl: plan.currentUrl } }
        );
        plan.log(`Task progress updated in DB: ${progress}%`);
    }
    
    // Check if the task wasn't explicitly completed with task_complete
    // AND the loop exited normally (not due to error or explicit break with exitPlanExecution)
    if (!taskCompleted && !plan.exitPlanExecution) {
      // This is a genuine case of reaching maximum steps without completion
      const summary = `Task reached maximum steps (${plan.maxSteps}) without explicit completion. Current URL: ${plan.currentUrl}`;
      plan.log(`Task maximum steps reached: marking as complete with ${plan.steps.length} steps executed.`);
      
      // Mark as completed with the max steps summary
      plan.markCompleted(summary);
      
      const finalResult = await processTaskCompletion(
        userId,
        taskId,
        plan.steps.map(step => step.result || { success: false }),
        prompt,
        runDir,
        runId
      );
      
      await Task.updateOne(
        { _id: taskId },
        { 
          $set: { 
            status: 'completed', 
            progress: 100, 
            result: finalResult, 
            endTime: new Date(), 
            summary,
            completionReason: 'max_steps' // Add a reason field to differentiate
          } 
        }
      );
      
      // --- Save final assistant message to both ChatHistory and Message ---
      let taskChatHistory = await ChatHistory.findOne({ userId });
      if (!taskChatHistory) taskChatHistory = new ChatHistory({ userId, messages: [] });
      
      // Add the max steps message to chat history
      taskChatHistory.messages.push({
        role: 'assistant',
        content: summary,
        timestamp: new Date(),
        meta: {
          completionReason: 'max_steps'
        }
      });
      await taskChatHistory.save();
      
      // Create the max steps message in the Message collection
      await Message.create({
        userId,
        role: 'assistant',
        type: 'command',
        content: summary,
        taskId,
        timestamp: new Date(),
        meta: {
          completionReason: 'max_steps',
          summary: finalResult.aiPrepared.summary,
          nexusReportUrl: finalResult.nexusReportUrl,
          landingReportUrl: finalResult.landingReportUrl,
          errorReportUrl: finalResult.errorReportUrl || null,
          screenshot: finalResult.screenshot || finalResult.screenshotPath || null,
          screenshotPath: finalResult.screenshotPath || finalResult.screenshot || null
        }
      });
      
      // Log that we're using the max steps message
      plan.log(`Saved 'reached maximum steps' message to chat history and message collection.`);
    }
  } catch (error) {
    console.error(`[ProcessTask] Error in task ${taskId}:`, error);
    plan.log(`Error encountered: ${error.message}`, { stack: error.stack });
    
    // Generate an error report
    let errorReportPath = null;
    let errorReportUrl = null;
    try {
      // Import the generateErrorReport function from the report generator
      const { generateErrorReport } = await import('./src/utils/reportGenerator.js');
      errorReportPath = await generateErrorReport(prompt, error, plan, runId, REPORT_DIR);
      if (errorReportPath) {
        // Convert the file path to a URL
        const reportFilename = path.basename(errorReportPath);
        errorReportUrl = `/nexus_run/report/${reportFilename}`;
        console.log(`[ProcessTask] Generated error report: ${errorReportUrl}`);
      }
    } catch (reportError) {
      console.error(`[ProcessTask] Failed to generate error report:`, reportError);
    }
    
    // Include the error report URL in the WebSocket update
    sendWebSocketUpdate(userId, {
      event: 'taskError',
      taskId,
      error: error.message,
      errorReport: errorReportUrl,
      log: plan.planLog.slice(-10)
    });
    
    // Update the task with the error report URL
    const taskUpdate = { 
      status: 'error', 
      error: error.message, 
      endTime: new Date()
    };
    
    if (errorReportUrl) {
      taskUpdate.errorReportUrl = errorReportUrl;
    }
    
    await Task.updateOne(
      { _id: taskId },
      { $set: taskUpdate }
    );
    
    // --- Save error message as assistant message to both ChatHistory and Message ---
    let taskChatHistory = await ChatHistory.findOne({ userId });
    if (!taskChatHistory) taskChatHistory = new ChatHistory({ userId, messages: [] });
    
    // Format a message that includes the error report link if available
    const errorMessage = errorReportUrl 
      ? `Error: ${error.message}\n\nA detailed error report is available: [View Error Report](javascript:void(0); onclick="window.open('${errorReportUrl}', '_blank')")` 
      : `Error: ${error.message}`;
    
    taskChatHistory.messages.push({
      role: 'assistant',
      content: errorMessage,
      timestamp: new Date()
    });
    await taskChatHistory.save();
    
    // Save to Message collection with error report metadata
    await Message.create({
      userId,
      role: 'assistant',
      type: 'command',
      content: errorMessage,
      taskId,
      timestamp: new Date(),
      meta: { 
        error: error.message,
        errorReportUrl: errorReportUrl || null
      }
    });
    // -------------------------------------------------------------
  } finally {
    console.log(`[ProcessTask] Cleaning up browser session for task ${taskId}`);
    await cleanupBrowserSession(taskId);

    console.log(`[ProcessTask] Task ${taskId} finished with ${plan.steps.length} steps executed.`);
    
    try {
      await Task.updateOne(
        { _id: taskId },
        { $set: { planSummary: plan.getSummary(), stepsExecuted: plan.steps.length } }
      );
      plan.log("Plan summary saved to database.");
    } catch (dbError) {
      console.error(`[ProcessTask] Error saving plan summary:`, dbError);
    }
  }
}

function cleanForPrompt(data) {
  if (data == null) return "";
  let str = typeof data === 'string' ? data : JSON.stringify(data, null, 2);
  // Remove known placeholder text
  if (str.trim() === "Structured data") return "";
  return str.trim();
}

/**
 * Track token usage for a user
 * @param {string} userId - User ID
 * @param {number} tokensUsed - Number of tokens used
 * @param {string} model - LLM model used
 */
async function trackTokenUsage(userId, tokensUsed, model = 'gpt-4o') {
  try {
    if (!userId || tokensUsed <= 0) return;
    
    // Find or create billing record
    let billing = await Billing.findOne({ userId });
    
    if (!billing) {
      billing = new Billing({
        userId,
        tokens: { used: 0, available: 1000 }, // Start with 1000 free tokens
        requests: { count: 0, limit: 100 },
        plan: 'free'
      });
    }
    
    // Update token usage
    billing.tokens.used += tokensUsed;
    
    // Add transaction for usage
    billing.transactions.push({
      type: 'usage',
      amount: tokensUsed / 1000, // Amount in USD equivalent
      tokens: tokensUsed,
      timestamp: new Date(),
      details: `Used ${tokensUsed} tokens with model ${model}`
    });
    
    // Increment request count
    billing.requests.count += 1;
    
    await billing.save();
    console.log(`Updated token usage for user ${userId}: +${tokensUsed} tokens used`);
    
    // Check if user is out of tokens
    if (billing.tokens.available <= billing.tokens.used && billing.plan !== 'free') {
      console.warn(`User ${userId} has used all available tokens`);
      // Here you could implement logic to notify the user or restrict access
    }
  } catch (err) {
    console.error('Error tracking token usage:', err);
  }
}

/**
 * Helper function to add intermediate results to a task
 * @param {string} userId - User ID
 * @param {string} taskId - Task ID
 * @param {Object} result - Result to add
 */
async function addIntermediateResult(userId, taskId, result) {
  try {
    // Only keep fields you care about, truncating any large text.
    const cleanedResult = {
      success: result.success,
      currentUrl: result.currentUrl,
      extractedInfo: typeof result.extractedInfo === 'string'
        ? result.extractedInfo.substring(0, 1500) + '...'
        : 'Complex data omitted',
      navigableElements: Array.isArray(result.navigableElements) 
        ? result.navigableElements.slice(0, 30) 
        : [],
      screenshotPath: result.screenshotPath,  // Only store path/URL, not raw base64
      timestamp: new Date()
    };

    await Task.updateOne(
      { _id: taskId },
      { 
        $push: { intermediateResults: cleanedResult },
        $set: {
          currentUrl: result.currentUrl,
          lastUpdate: new Date()
        }
      }
    );
  } catch (error) {
    console.error(`[addIntermediateResult] Error:`, error);
  }
}

async function extractRichPageContext(agent, page, command, query) {
  const currentUrl = await page.url();
  const domainType = detectDomainType(currentUrl);
  const domainSpecificPrompt = generateDomainSpecificPrompt(domainType);
  
  const combinedQuery = `
After executing "${command}", thoroughly analyze the page and return a JSON object with the following structure:
{
  "main_content": "Describe the main content visible on the page (prices, titles, important information).",
  "navigable_elements": [
    "List ALL clickable and navigable elements with their EXACT text as shown on screen."
  ],
  "interactive_controls": [
    "List ALL interactive controls (sliders, toggles, filters, etc.) with their EXACT labels if visible."
  ],
  "data_visualization": [
    "List ALL chart controls, time selectors, indicator buttons with their EXACT labels. Detail chart type (line or graph)"
  ],
  "product_filters": [
    "List ALL product filtering options with their EXACT labels."
  ],
  "search_fields": [
    "List any search fields or input areas with their placeholder text."
  ],
  "pagination": "Describe any pagination controls."
}

${domainSpecificPrompt}

IGNORE ALL IMAGES of phones, laptops, devices, billboards, or any marketing images simulating data presentation.
Detail charts or graphs including chart type (line/bar/candlestick)
Ensure you return valid JSON. If any field is not present, return an empty string or an empty array as appropriate.
[END OF INSTRUCTION]
${query}
  `;
 
  try {
    let extractedInfo = await agent.aiQuery(combinedQuery);
    if (typeof extractedInfo !== 'string') {
      if (extractedInfo && typeof extractedInfo === 'object') {
        const pageContent = extractedInfo.main_content || "No content extracted";
        const navigableElements = [
          ...(Array.isArray(extractedInfo.navigable_elements) ? extractedInfo.navigable_elements : []),
          ...(Array.isArray(extractedInfo.interactive_controls) ? extractedInfo.interactive_controls : []),
          ...(Array.isArray(extractedInfo.data_visualization) ? extractedInfo.data_visualization : []),
          ...(Array.isArray(extractedInfo.product_filters) ? extractedInfo.product_filters : [])
        ];
        return { pageContent, navigableElements };
      }
      return { pageContent: "No content extracted", navigableElements: [] };
    }
    
    let pageContent = extractedInfo;
    let navigableElements = [];
    try {
      const sections = extractedInfo.split(/(?:\r?\n){1,}/);
      const elementKeywords = [
        "clickable", "navigable", "button", "link", "menu", "filter", "toggle", 
        "checkbox", "select", "dropdown", "chart", "control", "tab", "icon",
        "slider", "candlestick", "time frame", "period", "indicator"
      ];
      
      for (const section of sections) {
        if (elementKeywords.some(keyword => section.toLowerCase().includes(keyword))) {
          const newElements = section.split(/\r?\n/)
                                    .filter(line => line.trim())
                                    .map(line => line.trim());
          navigableElements = [...navigableElements, ...newElements];
        }
      }
      navigableElements = [...new Set(navigableElements)];
    } catch (parseError) {
      console.log("[Rich Context] Error parsing navigable elements:", parseError);
    }
   
    return { 
      pageContent: pageContent || "No content extracted", 
      navigableElements 
    };
  } catch (queryError) {
    console.error(`[Rich Context] Error in AI query:`, queryError);
    return { pageContent: "Error extracting page content: " + queryError.message, navigableElements: [] };
  }
}

function detectDomainType(url) {
  const urlLower = url.toLowerCase();
  
  if (urlLower.includes('dextools') || urlLower.includes('dexscreener') ||
      urlLower.includes('coinbase') || urlLower.includes('coingecko') ||
      urlLower.includes('coinmarketcap') || urlLower.includes('binance') ||
      urlLower.includes('jupiterexchange')) {
    return 'cryptoSpecial';
  }
  if (urlLower.includes('amazon') || urlLower.includes('ebay') || 
      urlLower.includes('walmart') || urlLower.includes('etsy')) {
    return 'ecommerce';
  }
  if (urlLower.includes('twitter') || urlLower.includes('facebook') ||
      urlLower.includes('instagram') || urlLower.includes('tiktok')) {
    return 'social';
  }
  return 'general';
}

function generateDomainSpecificPrompt(domainType) {
  if (domainType === 'cryptoSpecial') {
    return `
CRYPTO SPECIAL INTERFACE DETECTED (e.g., Dextools, Dexscreener, Coinbase, Coingecko, Jupiter Exchange):
- Note the side menus, top navigation bars, and dashboard sections.
- Identify buttons such as "Trade", "Charts", "Market", "Analysis".
- Include any filtering dropdowns, time frame selectors, and graph toggles.
- List any visible labels of clickable links or tabs.
    `;
  } else if (domainType === 'ecommerce') {
    return `
ECOMMERCE SITE DETECTED: Focus on product filters, sort options, "Add to cart" buttons, and product variations.
    `;
  } else if (domainType === 'social') {
    return `
SOCIAL MEDIA SITE DETECTED: Focus on post creation, reply/comment buttons, and timeline navigation controls.
    `;
  } else {
    return `
GENERAL SITE DETECTED: Be comprehensive in finding all interactive elements to navigate this type of website. Emphasize clickable links, menus, and controls.
    `;
  }
}

/**
 * Advanced popup and obstacle handler for web browsing
 * @param {Object} page - Puppeteer page object
 * @param {Object} agent - Browser agent
 * @returns {Object} - Result of the preparation
 */
async function handlePageObstacles(page, agent) {
  console.log(`ðŸ” [Obstacles] Checking for page obstacles...`);
  const results = {
    obstacles: [],
    actionsAttempted: [],
    success: false
  };

  try {
    // Listen for any dialogs (alerts, confirms, prompts) and auto-accept them.
    page.on('dialog', async (dialog) => {
      console.log(`ðŸ”” [Obstacles] Dialog detected: ${dialog.type()} - ${dialog.message()}`);
      results.obstacles.push(`Dialog: ${dialog.type()} - ${dialog.message()}`);
      await dialog.accept();
      results.actionsAttempted.push(`Accepted ${dialog.type()} dialog`);
    });

    // Prepare a text instruction prompt for obstacles.
    const obstacleCheckPrompt = `
      Analyze the current page for common obstacles such as:
      1. Cookie consent banners,
      2. Newsletter signup modals,
      3. Login walls,
      4. Captcha or Turnstile challenges,
      5. Overlays or popups blocking content.
      
      For each obstacle, list any dismiss button text visible (e.g., "Accept", "Close", "No thanks"). If no obstacles or popups are found, return "no obstacles" or "none detected" only.
      Return a structured answer.
    `;
    
    // Execute the obstacle detection query.
    let obstacles = await agent.aiQuery(obstacleCheckPrompt);
    // Normalize obstacles to text regardless of whether it comes as a string or object.
    let obstaclesText = '';
    if (typeof obstacles === 'string') {
      obstaclesText = obstacles;
    } else if (typeof obstacles === 'object') {
      obstaclesText = JSON.stringify(obstacles, null, 2);
    } else {
      obstaclesText = String(obstacles);
    }
    
    // If no obstacles are detected in text, mark success.
    if (typeof obstaclesText === 'string' &&
        (obstaclesText.toLowerCase().includes('no obstacles') ||
         obstaclesText.toLowerCase().includes('none detected'))) {
      console.log(`âœ… [Obstacles] No obstacles detected.`);
      results.success = true;
      return results;
    }
    
    // Otherwise, log the detected obstacles.
    console.log(`âš ï¸ [Obstacles] Detected: ${obstaclesText.slice(0, 150)}...`);
    results.obstacles.push(obstaclesText);
    
    // Define a list of dismissal actions to attempt.
    const dismissActions = [
      "Find and click 'Accept', 'Accept All', 'I Accept', 'I Agree', or 'Agree'",
      "Find and click 'Continue', 'Close', 'Got it', 'I understand', or 'OK'",
      "Look for and click 'X', 'Close', 'Skip', 'No thanks', or 'Maybe later'",
      "If a CAPTCHA is present, attempt to solve or reload the challenge",
      "Try pressing the 'Escape' key or clicking outside a modal"
    ];
    
    let attemptCount = 0;
    const maxAttempts = 3; // Limit the number of times to retry a single dismiss action.
    
    // Iterate over each dismissal action.
    for (const action of dismissActions) {
      attemptCount = 0;
      let cleared = false;
      while (attemptCount < maxAttempts) {
        try {
          console.log(`ðŸ”§ [Obstacles] Attempting dismissal: ${action}`);
          results.actionsAttempted.push(action);
          // Use the agent's action function. Ideally, replace a raw text string with a dedicated method.
          // For example: await agent.scroll({ startBox: [0, 0, 1280, 720], direction: 'down' })
          // For now, we assume aiAction accepts this text.
          await agent.aiAction(action);
          // Wait for a moment to let the page update.
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Check if obstacles are still present.
          const recheck = await agent.aiQuery("Are there any popups, overlays, or banners blocking the main content?");
          if (typeof recheck === 'string' && 
              (recheck.toLowerCase().includes('no') || 
               recheck.toLowerCase().includes('cleared') ||
               recheck.toLowerCase().includes('gone'))) {
            console.log(`âœ… [Obstacles] Cleared with action: ${action}`);
            results.success = true;
            cleared = true;
            break;
          }
        } catch (dismissError) {
          console.log(`âŒ [Obstacles] Dismissal error on attempt ${attemptCount + 1} for action "${action}": ${dismissError.message}`);
        }
        attemptCount++;
      }
      if (cleared) break;
    }
    
    if (!results.success) {
      console.log(`âš ï¸ [Obstacles] Unable to clear obstacles after ${maxAttempts * dismissActions.length} attempts.`);
    }
    
    return results;
  } catch (error) {
    console.error(`âŒ [Obstacles] Error during obstacle handling: ${error.message}`);
    results.obstacles.push(`Error: ${error.message}`);
    return results;
  }
}

// Browser session cleanup utilities

async function cleanupBrowserSession(taskId) {
  try {
    if (!activeBrowsers.has(taskId)) return;
    
    const { browser, page, release } = activeBrowsers.get(taskId);
    
    // Close browser resources
    if (page && !page.isClosed()) await page.close();
    if (browser) await browser.close();
    if (release) release();
    
    // Remove from tracking
    activeBrowsers.delete(taskId);
    
    console.log(`Successfully cleaned up browser session for task ${taskId}`);
    return true;
  } catch (err) {
    console.error(`Failed to cleanup browser session for task ${taskId}:`, err);
    return false;
  }
}

// Add cleanup handler to process termination events
process.on('SIGTERM', async () => {
  console.log('SIGTERM received - cleaning up browser sessions');
  for (const [taskId] of activeBrowsers) {
    await cleanupBrowserSession(taskId);
  }
});

process.on('SIGINT', async () => {
  console.log('SIGINT received - cleaning up browser sessions');
  for (const [taskId] of activeBrowsers) {
    await cleanupBrowserSession(taskId);
  }
  process.exit(0);
});

// --- Helper: Ensure userId is present in session, generate guest if needed ---
function ensureUserId(req, res, next) {
  if (!req.session.user) {
    req.session.user = 'guest_' + Date.now() + '_' + Math.floor(Math.random()*100000);
    console.debug('[DEBUG] ensureUserId: Generated guest userId', req.session.user);
  } else {
    console.debug('[DEBUG] ensureUserId: Found userId in session', req.session.user);
  }
  next();
}

// --- API: Who Am I (userId sync endpoint) ---
app.get('/api/whoami', (req, res) => {
  try {
    let userId = null;
    if (req.session && req.session.user) {
      userId = req.session.user;
      console.debug('[whoami] Returning userId from session:', userId);
    } else if (req.session) {
      userId = 'guest_' + Date.now() + '_' + Math.floor(Math.random()*100000);
      req.session.user = userId;
      console.debug('[whoami] Generated new guest userId:', userId);
    } else {
      // Session middleware is broken or not present
      userId = 'guest_' + Date.now() + '_' + Math.floor(Math.random()*100000);
      console.warn('[whoami] WARNING: req.session missing, returning fallback guest userId:', userId);
    }
    res.json({ userId });
  } catch (err) {
    console.error('[whoami] ERROR:', err);
    res.status(500).json({ error: 'Failed to get userId', detail: err.message });
  }
});

// --- Robust API: Who Am I (no /api prefix, for proxy rewrite) ---
app.get('/whoami', (req, res) => {
  try {
    let userId = null;
    if (req.session && req.session.user) {
      userId = req.session.user;
      console.debug('[whoami] Returning userId from session:', userId);
    } else if (req.session) {
      userId = 'guest_' + Date.now() + '_' + Math.floor(Math.random()*100000);
      req.session.user = userId;
      console.debug('[whoami] Generated new guest userId:', userId);
    } else {
      userId = 'guest_' + Date.now() + '_' + Math.floor(Math.random()*100000);
      console.warn('[whoami] WARNING: req.session missing, returning fallback guest userId:', userId);
    }
    res.json({ userId });
  } catch (err) {
    console.error('[whoami] ERROR:', err);
    res.status(500).json({ error: 'Failed to get userId', detail: err.message });
  }
});

/**
 * Unified NLI endpoint:
 * - If we detect it's a â€œtask,â€ do your existing logic.
 * - If we detect it's â€œchat,â€ stream partial output from the LLM directly.
 */
app.post('/api/nli', requireAuth, async (req, res) => {
  // Accept both { prompt } and legacy { inputText }
  let prompt = req.body.prompt;
  if (!prompt && req.body.inputText) {
    prompt = req.body.inputText;
    console.debug('[DEBUG] /nli: Using legacy inputText as prompt:', prompt);
  }
  if (typeof prompt !== 'string') {
    console.error('[ERROR] /nli: Prompt must be a string. Got:', typeof prompt, prompt);
    return res.status(400).json({ success: false, error: 'Prompt must be a string.' });
  }

  // Sanitize and validate prompt
  prompt = prompt.trim();
  if (prompt.length === 0) {
    console.error('[ERROR] /nli: Prompt is empty after trim.');
    return res.status(400).json({ success: false, error: 'Prompt cannot be empty.' });
  }
  const MAX_PROMPT_LENGTH = 5000;
  if (prompt.length > MAX_PROMPT_LENGTH) {
    console.error(`[ERROR] /nli: Prompt too long (${prompt.length} chars). Max is ${MAX_PROMPT_LENGTH}.`);
    return res.status(400).json({ success:false, error: `Prompt too long (max ${MAX_PROMPT_LENGTH} chars).` });
  }

  const userId = req.session.user;
  const user   = await User.findById(userId).select('email openaiApiKey').lean();
  if (!user) return res.status(400).json({ success: false, error: 'User not found' });

  let classification;
  try {
    classification = await openaiClassifyPrompt(prompt, userId);
  } catch (err) {
    console.error('Classification error', err);
    classification = 'task';
  }

  if (classification === 'task') {
    // fetch user for email
    const userDoc = await User.findById(userId).lean();
    const userEmail = userDoc?.email;
    // persist user in chat history
    let chatHistory = await ChatHistory.findOne({ userId }) || new ChatHistory({ userId, messages: [] });
    chatHistory.messages.push({ role: 'user', content: prompt, timestamp: new Date() });
    await chatHistory.save();

    const taskId = new mongoose.Types.ObjectId();
    const runId  = uuidv4();
    const runDir = path.join(NEXUS_RUN_DIR, runId);
    fs.mkdirSync(runDir, { recursive: true });

    // â€¦ save Task + push to User.activeTasks â€¦
    await new Task({ _id: taskId, userId, command: prompt, status: 'pending', progress: 0, startTime: new Date(), runId }).save();
    await User.updateOne({ _id: userId }, { $push: { activeTasks: { _id: taskId.toString(), command: prompt, status: 'pending', startTime: new Date() } } });

    // Use browserEngine if set in the session for browser automation tasks
    const engineToUse = req.session.browserEngine;
    if (engineToUse) {
      console.log(`[POST /api/nli] Using browser engine ${engineToUse} from session for task`);
    }

    sendWebSocketUpdate(userId, { event: 'taskStart', payload: { taskId: taskId.toString(), command: prompt, startTime: new Date() } });
    // Call processTask with correct parameter order: userId, userEmail, taskId, runId, runDir, prompt, url, engine
    processTask(userId, userEmail, taskId.toString(), runId, runDir, prompt, null, engineToUse);
    res.set({
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive'
    });
    res.flushHeaders();
    res.write('data: ' + JSON.stringify({ event: 'taskStart', payload: { taskId: taskId.toString(), command: prompt, startTime: new Date() } }) + '\n\n');
    // poll for updates
    const interval = setInterval(async () => {
      try {
        const task = await Task.findById(taskId).lean();
        if (!task) {
          clearInterval(interval);
          res.write('data: ' + JSON.stringify({ event: 'taskError', taskId: taskId.toString(), error: 'Task not found' }) + '\n\n');
          return res.end();
        }
        const done = ['completed','error'].includes(task.status);
        const evtName = done ? 'taskComplete' : 'stepProgress';
        const payload = { taskId: taskId.toString(), progress: task.progress, result: task.result, error: task.error };
        res.write('data: ' + JSON.stringify({ event: evtName, ...payload }) + '\n\n');
        if (done) {
          clearInterval(interval);
          return res.end();
        }
      } catch (err) {
        console.error('Task polling error:', err);
      }
    }, 2000);
    req.on('close', () => clearInterval(interval));
  } else {
    // chat streaming
    res.set({
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive'
    });
    res.flushHeaders();
    for await (const evt of streamNliThoughts(userId, prompt)) {
      res.write('data: ' + JSON.stringify(evt) + '\n\n');
    }
    res.end();
  }
});

// --- Unified Message Retrieval Endpoint (backward compatible) ---
app.get('/api/messages', requireAuth, async (req, res) => {
  try {
    const userId = req.session.user;
    const limit = parseInt(req.query.limit, 10) || 20;
    // New schema: unified Message collection
    let messages = await Message.find({ userId })
      .sort({ timestamp: -1 })
      .limit(limit)
      .lean();
    // Backward compatibility: if empty, try ChatHistory
    if (!messages.length) {
      const chatHistory = await ChatHistory.findOne({ userId });
      if (chatHistory && chatHistory.messages) {
        messages = chatHistory.messages.slice(-limit).reverse().map(m => ({
          userId,
          role: m.role,
          type: 'chat',
          content: m.content,
          timestamp: m.timestamp || null,
          legacy: true
        }));
      }
    }
    return res.json({ success: true, messages: messages.reverse() }); // oldest first
  } catch (err) {
    console.error('[GET /messages] Error:', err);
    return res.status(500).json({ success: false, error: err.message });
  }
});

// Helper: async generator for streaming thought (and tool) events
async function* streamNliThoughts(userId, prompt) {
  // Persist user prompt
  await new Message({ userId, role: 'user', type: 'chat', content: prompt, timestamp: new Date() }).save();

  // Build context (last 20 messages)
  let history = await Message.find({ userId, role: { $in: ['user','assistant'] } })
    .sort({ timestamp: -1 }).limit(20).lean();
  history = history.reverse();
  
  let buffer = '';
  let fullReply = '';
  
  // Get a chat client using our chat-specific function
  // This automatically selects the user's preferred chat model
  const openaiClient = await getUserOpenAiClient(userId);
  
  // The model will be automatically selected based on the user's chat model preference
  // Default to gpt-4o if extraction fails
  let chatModel = 'gpt-4o';
  
  // Extract the model from the client's default query
  if (openaiClient.defaultQuery?.engine) {
    chatModel = openaiClient.defaultQuery.engine;
  }
  
  console.log(`[Chat] Creating stream with model: ${chatModel}`);
  
  try {
    // Create the stream with the appropriate model
    const stream = await openaiClient.chat.completions.create({
      model: chatModel,
      messages: history.map(m=>({ role:m.role, content:m.content })),
      stream: true,
      temperature: 0.7,
      max_tokens: 700
    });
    
    // Process the stream chunks
    for await (const chunk of stream) {
      const delta = chunk.choices[0]?.delta;
      
      if (delta?.content) {
        buffer += delta.content;
        fullReply += delta.content;
        yield { event: 'thoughtUpdate', text: delta.content };
        if (/[.?!]\s$/.test(buffer) || buffer.length > 80) buffer = '';
      }
      if (delta?.tool_calls) {
        for (const call of delta.tool_calls) {
          yield {
            event: 'functionCallPartial',
            functionName: call.function.name,
            partialArgs: call.function.arguments || ''
          };
        }
      }
    }
    
    // Return the complete response
    yield { event: 'thoughtComplete', text: fullReply };
  } catch (error) {
    // Handle authentication errors specially
    if (error.status === 401 || error.message?.includes('auth')) {
      const provider = openaiClient.defaultQuery?.provider || 'unknown';
      const errorMessage = `Authentication error with ${provider} API key: ${error.message}`;
      console.error(errorMessage);
      
      // Return a user-friendly error message
      yield { 
        event: 'error', 
        text: `Sorry, there was an authentication problem with your ${provider} API key. ` +
              `Please check your API key in Settings > API Keys and ensure it's valid.`
      };
    } 
    // Handle rate limit errors specifically
    else if (error.status === 429 || error.code === 'insufficient_quota' || error.message?.includes('exceeded your current quota')) {
      const provider = openaiClient.defaultQuery?.provider || 'OpenAI';
      const errorMessage = `Rate limit exceeded with ${provider} API: ${error.message}`;
      console.error(errorMessage);
      
      // Return a specific rate limit error message to the timeline
      yield { 
        event: 'error', 
        text: `ðŸš« API Quota Exceeded: You've exceeded your ${provider} API quota. ` +
              `Please check your subscription plan and billing details or try switching to a different model in Settings.`
      };
    } else {
      // Handle other errors
      console.error('Error in chat stream:', error);
      yield { 
        event: 'error', 
        text: `Sorry, there was an error: ${error.message}. Please try again.`
      };
    }
  }
  
  // No more code needed here since we're handling everything in the try/catch block
  
  // We already yield the thoughtComplete event in the try/catch block above
  // The final response will be handled by the handleFinalResponse function
  // which is called when we receive the thoughtComplete event
}

const handleFinalResponse = async (userId, finalResponse) => {
  try {
    await Promise.all([
      // Store in Message collection for individual access
      Message.create({
        userId,
        content: finalResponse,
        role: 'assistant',
        type: 'system',  // Using validated enum value
        timestamp: new Date()
      }),
      
      // Append to ChatHistory for conversation context
      ChatHistory.updateOne(
        { userId },
        { 
          $push: { 
            messages: { 
              role: 'assistant', 
              content: finalResponse,
              timestamp: new Date() 
            } 
          } 
        },
        { upsert: true }
      )
    ]);
    
    sendWebSocketUpdate(userId, {
      event: 'nliResponsePersisted',
      content: finalResponse
    });
  } catch (err) {
    console.error('[NLI] Error persisting final response:', err);
    // Consider adding retry logic here if needed
  }
};

app.get('/api/nli', requireAuth, async (req, res) => {
  // Get user ID from session first thing
  const userId = req.session.user;
  const prompt = req.query.prompt;
  const requestedEngine = req.query.engine || req.session.browserEngine;
  
  if (typeof prompt !== 'string' || !prompt.trim()) {
    res.status(400).json({ success: false, error: 'Prompt query parameter is required.' });
    return;
  }
  
  // If engine is specified, validate it
  if (requestedEngine) {
    const validEngines = ['gpt-4o', 'qwen-2.5-vl-72b', 'gemini-2.5-pro', 'ui-tars'];
    if (!validEngines.includes(requestedEngine)) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid engine specified'
      });
    }
    
    // Store the selected browser engine in the session for future browser automation tasks
    req.session.browserEngine = requestedEngine;
    console.log(`[NLI] Updated browser engine to: ${requestedEngine} (this only affects automation tasks, not chat)`);
    
    // Check if the user has access to this engine
    const keyInfo = await checkEngineApiKey(userId, requestedEngine);
    
    if (!keyInfo.hasKey) {
      return res.status(400).json({
        success: false,
        error: `No API key available for ${requestedEngine}. Please configure one in Settings.`,
        keyInfo
      });
    }
    
    // If using default key, notify the user
    if (keyInfo.usingDefault) {
      notifyApiKeyStatus(userId, keyInfo);
    }
  }
  
  // IMPORTANT: Clean up old tempEngine from session if it exists
  // This ensures complete separation between chat and browser automation
  if (req.session.tempEngine) {
    console.log(`[NLI] Removing deprecated tempEngine=${req.session.tempEngine} from session`);
    // If we have tempEngine but no browserEngine, migrate it
    if (!req.session.browserEngine) {
      req.session.browserEngine = req.session.tempEngine;
      console.log(`[NLI] Migrated tempEngine to browserEngine=${req.session.browserEngine}`);
    }
    // Remove the old variable
    delete req.session.tempEngine;
    req.session.save();
  }
  
  // classify prompt
  let classification;
  try {
    classification = await openaiClassifyPrompt(prompt, userId);
  } catch (err) {
    console.error('Classification error', err);
    classification = 'chat';
  }

  // Fetch user document (needed for multiple code paths)
  const userDoc = await User.findById(userId).lean();
  const userEmail = userDoc?.email;
  
  if (classification === 'task') {
    
    // Persist user command in chat history
    let chatHistory = await ChatHistory.findOne({ userId }) || new ChatHistory({ userId, messages: [] });
    chatHistory.messages.push({ role: 'user', content: prompt, timestamp: new Date() });
    await chatHistory.save();
    
    // Create task
    const taskId = new mongoose.Types.ObjectId();
    const runId  = uuidv4();
    const runDir = path.join(NEXUS_RUN_DIR, runId);
    fs.mkdirSync(runDir, { recursive: true });
    
    // Determine the correct execution mode based on engine and command content
    
    // Map engine to provider for execution mode determination
    const engineToProvider = {
      'gpt-4o': 'openai',
      'qwen-2.5-vl-72b': 'qwen',
      'gemini-2.5-pro': 'google',
      'ui-tars': 'uitars'
    };
    
    // Get user's execution mode preference 
    const executionModePreference = userDoc.settings?.executionMode || 'step-planning';
    
    // Determine current engine and provider
    const engine = req.session.browserEngine || 'gpt-4o'; // Default to gpt-4o if not specified
    const provider = engineToProvider[engine] || 'openai';
    
    // Determine actual execution mode based on rules
    const executionMode = determineExecutionMode(provider, prompt, executionModePreference);
    console.log(`[Task] Using execution mode: ${executionMode} for provider: ${provider} (engine: ${engine})`);
    
    // Save task to database
    await new Task({ 
      _id: taskId, 
      userId, 
      command: prompt, 
      status: 'pending', 
      progress: 0, 
      startTime: new Date(), 
      runId,
      executionMode,
      engine
    }).save();
    
    // Update user's active tasks
    await User.updateOne({ _id: userId }, { 
      $push: { 
        activeTasks: { 
          _id: taskId.toString(), 
          command: prompt, 
          status: 'pending', 
          startTime: new Date(),
          executionMode,
          engine
        } 
      } 
    });
    
    // Launch task processing with correct parameter order
    // (userId, userEmail, taskId, runId, runDir, prompt, url, engine)
    processTask(userId, userEmail, taskId.toString(), runId, runDir, prompt, null, null).catch(console.error);
    // send taskStart
    res.set({
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive'
    });
    res.flushHeaders();
    res.write('data: ' + JSON.stringify({ event: 'taskStart', payload: { taskId: taskId.toString(), command: prompt, startTime: new Date() } }) + '\n\n');
    // poll for updates
    const interval = setInterval(async () => {
      try {
        const task = await Task.findById(taskId).lean();
        if (!task) {
          clearInterval(interval);
          res.write('data: ' + JSON.stringify({ event: 'taskError', taskId: taskId.toString(), error: 'Task not found' }) + '\n\n');
          return res.end();
        }
        const done = ['completed','error'].includes(task.status);
        const evtName = done ? 'taskComplete' : 'stepProgress';
        
        // For completed tasks, ensure all report links are included in the payload
        let resultWithLinks = task.result || {};
        if (done) {
          // Guarantee all report URLs are present by providing fallbacks
          resultWithLinks = {
            ...resultWithLinks,
            landingReportUrl: resultWithLinks.landingReportUrl || resultWithLinks.runReport || null,
            nexusReportUrl: resultWithLinks.nexusReportUrl || null,
            runReport: resultWithLinks.runReport || resultWithLinks.landingReportUrl || null,
            reportUrl: resultWithLinks.reportUrl || resultWithLinks.nexusReportUrl || 
                      resultWithLinks.landingReportUrl || resultWithLinks.runReport || 
                      (resultWithLinks.screenshot ? resultWithLinks.screenshot : null)
          };
          console.log(`[TaskCompletion] Enhanced report links for task ${taskId}:`, {
            landingReportUrl: resultWithLinks.landingReportUrl,
            nexusReportUrl: resultWithLinks.nexusReportUrl,
            reportUrl: resultWithLinks.reportUrl
          });
        }
        
        const payload = { 
          taskId: taskId.toString(), 
          progress: task.progress, 
          result: resultWithLinks, 
          error: task.error 
        };
        res.write('data: ' + JSON.stringify({ event: evtName, ...payload }) + '\n\n');
        if (done) {
          clearInterval(interval);
          return res.end();
        }
      } catch (err) {
        console.error('Task polling error:', err);
      }
    }, 2000);
    req.on('close', () => clearInterval(interval));
  } else {
    // chat streaming
    res.set({
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive'
    });
    res.flushHeaders();
    for await (const evt of streamNliThoughts(userId, prompt)) {
      res.write('data: ' + JSON.stringify(evt) + '\n\n');
      if (evt.event === 'thoughtComplete') {
        await handleFinalResponse(userId, evt.text);
      }
    }
    res.end();
  }
});

// --- API: History endpoints ---
// History routes are now handled by historyRouter

// --- API: User Settings endpoints ---
app.get('/api/settings', requireAuth, async (req, res) => {
  try {
    const userId = req.session.user;
    const user = await User.findById(userId).exec();
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    // Extract only the settings information
    res.json({
      success: true,
      apiKeys: {
        gpt4o: user.apiKeys.gpt4o ? true : false,
        qwen: user.apiKeys.qwen ? true : false,
        gemini: user.apiKeys.gemini ? true : false,
        uitars: user.apiKeys.uitars ? true : false
      },
      preferredEngine: user.preferredEngine,
      executionMode: user.executionMode || 'step-planning',
      privacyMode: user.privacyMode || false,
      customUrls: user.customUrls || []
    });
  } catch (error) {
    console.error('Error fetching settings:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Public API endpoint to check available engines - works without auth for new users
app.get('/api/user/available-engines', async (req, res) => {
  try {
    const userId = req.session.user;
    
    // For first-time users without a user ID, provide default engines with system defaults
    if (!userId) {
      console.log('Available engines request for new user - providing defaults');
      const supportedEngines = Object.keys(ENGINE_KEY_MAPPING);
      
      // For new users, we'll assume all engines are available with system defaults
      const engineStatus = {};
      const availableEngines = supportedEngines;
      let usingAnyDefaultKey = true;
      
      // Populate engine status with default info
      supportedEngines.forEach(engine => {
        engineStatus[engine] = {
          available: true,
          usingDefault: true,
          keySource: 'system-default',
          keyType: ENGINE_KEY_MAPPING[engine]
        };
      });
      
      return res.json({ 
        success: true, 
        engineStatus,
        availableEngines,
        preferredEngine: 'gpt-4o',
        usingAnyDefaultKey
      });
    }
    
    // Use our standardized ENGINE_KEY_MAPPING for consistency
    const supportedEngines = Object.keys(ENGINE_KEY_MAPPING);
    
    // Create an array of promises for checking each engine
    const enginePromises = supportedEngines.map(engine => checkEngineApiKey(userId, engine));
    
    // Execute all promises in parallel with a timeout for safety
    const results = await Promise.allSettled(enginePromises);
    
    // Format the results
    const engineStatus = {};
    const availableEngines = [];
    let usingAnyDefaultKey = false;
    let usingAnyUserKey = false;
    
    // Process the results, handling any rejected promises
    results.forEach((result, index) => {
      const engine = supportedEngines[index];
      
      if (result.status === 'fulfilled') {
        const engineResult = result.value;
        engineStatus[engineResult.engine] = {
          available: engineResult.hasKey,
          usingDefault: engineResult.usingDefault,
          keySource: engineResult.keySource,
          keyType: engineResult.keyType
        };
        
        if (engineResult.hasKey) {
          availableEngines.push(engineResult.engine);
          
          // Send appropriate notifications based on key source
          if (engineResult.usingDefault) {
            usingAnyDefaultKey = true;
            // We'll send a collective notification about default keys below
          } else if (engineResult.keySource === 'user') {
            usingAnyUserKey = true;
            // Notify user that we're using their API key
            notifyApiKeyStatus(userId, engineResult);
          }
        } else {
          // Key missing - send notification for important engines
          if (engine === 'gpt-4o') {
            notifyApiKeyStatus(userId, engineResult);
          }
        }
      } else {
        // Handle rejected promise (engine check failed)
        console.warn(`Engine check failed for ${engine}:`, result.reason);
        engineStatus[engine] = {
          available: false,
          error: true,
          keySource: 'error',
          keyType: ENGINE_KEY_MAPPING[engine]
        };
      }
    });
    
    // Instead of WebSocket updates, return notification data with the response
    // This will be shown by the frontend notification system
    let notification = null;
    
    if (usingAnyDefaultKey) {
      notification = {
        title: 'Using System API Keys',
        message: 'You are using system default API keys. For unlimited usage, add your own API keys in Settings.',
        type: 'info',
        duration: 8000
      };
    } else if (usingAnyUserKey) {
      notification = {
        title: 'Using Your API Keys',
        message: 'Successfully using your own API keys - no usage limits apply.',
        type: 'success',
        duration: 5000
      };
    }
    
    // Get user's current preferred engine
    let preferredEngine = 'gpt-4o'; // Safe default
    try {
      const user = await User.findById(userId).select('preferredEngine').lean();
      preferredEngine = user?.preferredEngine || 'gpt-4o';
      
      // Ensure preferred engine is valid
      if (!supportedEngines.includes(preferredEngine)) {
        preferredEngine = 'gpt-4o';
      }
    } catch (userError) {
      console.error('Error fetching user preference:', userError);
    }
    
    // If no engines are available, add the default engine as available
    if (availableEngines.length === 0) {
      availableEngines.push('gpt-4o');
      engineStatus['gpt-4o'] = {
        available: true,
        usingDefault: true,
        keySource: 'fallback',
        keyType: 'openai'
      };
    }
    
    return res.json({ 
      success: true, 
      engineStatus,
      availableEngines,
      preferredEngine,
      usingAnyDefaultKey,
      notification // Include the notification in response
    });
  } catch (error) {
    console.error('Error checking available engines:', error);
    
    // Return a fallback response even on error
    return res.json({ 
      success: true, // Still return success to prevent frontend crashes
      error: error.message,
      availableEngines: ['gpt-4o'], // Always make at least GPT-4o available as fallback
      preferredEngine: 'gpt-4o',
      usingAnyDefaultKey: true,
      engineStatus: {
        'gpt-4o': { available: true, usingDefault: true, keySource: 'fallback' }
      }
    });
  }
});

// ENGINE_KEY_MAPPING and KEY_ENGINE_MAPPING are now defined in the global configuration section

// getEngineDisplayName is now defined in the global configuration section

// API endpoint for user API key management
app.post('/api/user/api-keys', requireAuth, async (req, res) => {
  try {
    const userId = req.session.user;
    const { apiKeyType, apiKey } = req.body;
    
    if (!userId) {
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }
    
    // Validate key type against our supported engines
    const validKeyTypes = Object.values(ENGINE_KEY_MAPPING);
    if (!validKeyTypes.includes(apiKeyType)) {
      return res.status(400).json({ 
        success: false, 
        error: `Invalid API key type. Supported types are: ${validKeyTypes.join(', ')}` 
      });
    }
    
    // Validate provided key
    if (!apiKey || apiKey.trim().length < 8) {  // Most API keys are longer than 8 characters
      return res.status(400).json({ success: false, error: 'Invalid API key provided' });
    }
    
    // Find user
    const user = await User.findOne({ _id: userId });
    
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    // Make sure apiKeys object exists
    if (!user.apiKeys) {
      user.apiKeys = {};
    }
    
    // Update the appropriate key
    user.apiKeys[apiKeyType] = apiKey;
    await user.save();
    
    // Get the corresponding engine for this key type
    const engineId = KEY_ENGINE_MAPPING[apiKeyType];
    const engineName = getEngineDisplayName(engineId);
    
    // Send notification about key update
    sendWebSocketUpdate(userId, {
      event: 'notification',
      type: 'success',
      title: 'API Key Updated',
      message: `Your ${engineName} API key has been updated successfully`
    });
    
    res.json({ 
      success: true, 
      message: `${engineName} API key updated successfully`,
      engineId,
      keyType: apiKeyType  
    });
  } catch (error) {
    console.error('Error updating API key:', error);
    res.status(500).json({ success: false, error: 'Internal server error' });
  }
});

// Delete user API key
app.delete('/api/user/api-keys', requireAuth, async (req, res) => {
  try {
    const userId = req.session.user;
    const { apiKeyType } = req.body;
    
    if (!userId) {
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }
    
    // Validate key type against our supported engines
    const validKeyTypes = Object.values(ENGINE_KEY_MAPPING);
    if (!validKeyTypes.includes(apiKeyType)) {
      return res.status(400).json({ 
        success: false, 
        error: `Invalid API key type. Supported types are: ${validKeyTypes.join(', ')}` 
      });
    }
    
    // Find user
    const user = await User.findOne({ _id: userId });
    
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    // Check if the key exists before attempting to delete
    if (!user.apiKeys || !user.apiKeys[apiKeyType]) {
      return res.status(404).json({ success: false, error: 'API key not found' });
    }
    
    // Delete the key
    delete user.apiKeys[apiKeyType];
    await user.save();
    
    // Get the corresponding engine for this key type
    const engineId = KEY_ENGINE_MAPPING[apiKeyType];
    const engineName = getEngineDisplayName(engineId);
    
    // Send notification about key deletion
    sendWebSocketUpdate(userId, {
      event: 'notification',
      type: 'info',
      title: 'API Key Removed',
      message: `Your ${engineName} API key has been removed`
    });
    
    res.json({ 
      success: true, 
      message: `${engineName} API key deleted successfully`,
      engineId,
      keyType: apiKeyType
    });
  } catch (error) {
    console.error('Error deleting API key:', error);
    res.status(500).json({ success: false, error: 'Internal server error' });
  }
});

// API endpoint to set user's execution mode preference
app.post('/api/user/set-execution-mode', requireAuth, async (req, res) => {
  try {
    const userId = req.session.user;
    const { mode } = req.body;
    
    if (!userId) {
      return res.status(401).json({ success: false, error: 'User not authenticated' });
    }
    
    // Validate execution mode
    const validModes = ['step-planning', 'action-planning'];
    if (!validModes.includes(mode)) {
      return res.status(400).json({ success: false, error: 'Invalid execution mode' });
    }
    
    // Find user
    const user = await User.findOne({ _id: userId });
    
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }
    
    // Update the user's execution mode
    user.executionMode = mode;
    await user.save();
    
    // Send notification about mode update
    sendWebSocketUpdate(userId, {
      event: 'notification',
      type: 'success',
      title: 'Execution Mode Updated',
      message: `Your execution mode has been set to ${mode === 'step-planning' ? 'Step Planning' : 'Action Planning (Autopilot)'}`
    });
    
    res.json({
      success: true,
      message: `Execution mode set to ${mode}`
    });
  } catch (error) {
    console.error('Error setting execution mode:', error);
    res.status(500).json({ success: false, error: 'Internal server error' });
  }
});

// API endpoint to set temporary engine preference
app.post('/api/user/set-engine', requireAuth, async (req, res) => {
  try {
    const userId = req.session.user;
    const { engineId, keyType } = req.body;
    
    // Validate engine against our standardized ENGINE_KEY_MAPPING
    if (!Object.keys(ENGINE_KEY_MAPPING).includes(engineId)) {
      return res.status(400).json({ 
        success: false, 
        error: `Invalid engine selected. Supported engines are: ${Object.keys(ENGINE_KEY_MAPPING).join(', ')}` 
      });
    }
    
    // Get the expected key type for this engine
    const expectedKeyType = ENGINE_KEY_MAPPING[engineId];
    
    // If client provided a key type, verify it matches our mapping
    if (keyType && keyType !== expectedKeyType) {
      console.warn(`Client provided key type ${keyType} doesn't match expected ${expectedKeyType} for engine ${engineId}`);
    }
    
    // Check if the engine is available for this user
    const keyInfo = await checkEngineApiKey(userId, engineId);
    let warning = null;
    
    // If no key is available, we'll still update the preference but return a warning
    if (!keyInfo.hasKey) {
      warning = `No API key available for ${getEngineDisplayName(engineId)}. Please add your API key in Settings.`;
    }
    
    // Store in session for temporary override
    req.session.tempEngine = engineId;
    
    // Also update user's preferred engine in database
    await User.findByIdAndUpdate(userId, { preferredEngine: engineId });
    
    // Send notification about key status if using default
    if (keyInfo.usingDefault) {
      notifyApiKeyStatus(userId, keyInfo);
    }
    
    return res.json({ 
      success: true, 
      message: `Engine set to ${getEngineDisplayName(engineId)}`,
      warning,
      keyInfo,
      engineId,
      keyType: expectedKeyType
    });
  } catch (error) {
    console.error('Error setting engine:', error);
    return res.status(500).json({ success: false, error: error.message });
  }
});

app.post('/api/settings', requireAuth, async (req, res) => {
  try {
    const userId = req.session.user;
    const { action } = req.body;
    const user = await User.findById(userId).exec();
    
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }

    // Handle different types of settings updates
    switch (action) {
      case 'saveApiKey':
        const { provider, key } = req.body;
        
        if (!provider || !key) {
          return res.status(400).json({ success: false, error: 'Provider and key are required' });
        }
        
        // Initialize apiKeys if it doesn't exist
        if (!user.apiKeys) {
          user.apiKeys = {};
        }
        
        // Save API key
        user.apiKeys[provider] = key;
        await user.save();
        
        return res.json({ success: true, message: `${provider} API key saved successfully` });

      case 'saveLlmPreferences':
        const { models } = req.body;
        
        if (!models) {
          return res.status(400).json({ success: false, error: 'Model preferences are required' });
        }
        
        // Initialize llmPreferences if it doesn't exist
        if (!user.llmPreferences) {
          user.llmPreferences = {};
        }
        
        // Update LLM preferences
        user.llmPreferences = {
          ...user.llmPreferences,
          ...models
        };
        
        await user.save();
        
        return res.json({ success: true, message: 'LLM preferences saved successfully' });
        
      default:
        return res.status(400).json({ success: false, error: 'Invalid action' });
    }
  } catch (error) {
    console.error('Error updating user settings:', error);
    return res.status(500).json({ success: false, error: 'Failed to update user settings' });
  }
});

app.delete('/api/settings', requireAuth, async (req, res) => {
  try {
    const userId = req.session.user;
    const { action, provider } = req.body;
    const user = await User.findById(userId).exec();
    
    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }

    if (action === 'deleteApiKey') {
      if (!provider) {
        return res.status(400).json({ success: false, error: 'Provider is required' });
      }
      
      // Check if apiKeys and the specific provider key exist
      if (user.apiKeys && user.apiKeys[provider]) {
        // Delete the key
        delete user.apiKeys[provider];
        await user.save();
        
        return res.json({ success: true, message: `${provider} API key deleted successfully` });
      } else {
        return res.status(404).json({ success: false, error: 'API key not found' });
      }
    } else {
      return res.status(400).json({ success: false, error: 'Invalid action' });
    }
  } catch (error) {
    console.error('Error deleting API key:', error);
    return res.status(500).json({ success: false, error: 'Failed to delete API key' });
  }
});

app.post('/api/nli', requireAuth, async (req, res) => {
  // Accept both { prompt } and legacy { inputText }
  let prompt = req.body.prompt;
  if (!prompt && req.body.inputText) {
    prompt = req.body.inputText;
    console.debug('[DEBUG] /nli: Using legacy inputText as prompt:', prompt);
  }
  if (typeof prompt !== 'string') {
    console.error('[ERROR] /nli: Prompt must be a string. Got:', typeof prompt, prompt);
    return res.status(400).json({ success: false, error: 'Prompt must be a string.' });
  }

  // Sanitize and validate prompt
  prompt = prompt.trim();
  if (prompt.length === 0) {
    console.error('[ERROR] /nli: Prompt is empty after trim.');
    return res.status(400).json({ success: false, error: 'Prompt cannot be empty.' });
  }
  const MAX_PROMPT_LENGTH = 5000;
  if (prompt.length > MAX_PROMPT_LENGTH) {
    console.error(`[ERROR] /nli: Prompt too long (${prompt.length} chars). Max is ${MAX_PROMPT_LENGTH}.`);
    return res.status(400).json({ success:false, error: `Prompt too long (max ${MAX_PROMPT_LENGTH} chars).` });
  }

  const userId = req.session.user;
  const user   = await User.findById(userId).select('email openaiApiKey').lean();
  if (!user) return res.status(400).json({ success: false, error: 'User not found' });

  let classification;
  try {
    classification = await openaiClassifyPrompt(prompt, userId);
  } catch (err) {
    console.error('Classification error', err);
    classification = 'task';
  }

  if (classification === 'task') {
    // fetch user for email
    const userDoc = await User.findById(userId).lean();
    const userEmail = userDoc?.email;
    // persist user in chat history
    let chatHistory = await ChatHistory.findOne({ userId }) || new ChatHistory({ userId, messages: [] });
    chatHistory.messages.push({ role: 'user', content: prompt, timestamp: new Date() });
    await chatHistory.save();

    const taskId = new mongoose.Types.ObjectId();
    const runId  = uuidv4();
    const runDir = path.join(NEXUS_RUN_DIR, runId);
    fs.mkdirSync(runDir, { recursive: true });

    // â€¦ save Task + push to User.activeTasks â€¦
    await new Task({ _id: taskId, userId, command: prompt, status: 'pending', progress: 0, startTime: new Date(), runId }).save();
    await User.updateOne({ _id: userId }, { $push: { activeTasks: { _id: taskId.toString(), command: prompt, status: 'pending', startTime: new Date() } } });

    sendWebSocketUpdate(userId, { event: 'taskStart', payload: { taskId: taskId.toString(), command: prompt, startTime: new Date() } });
    processTask(userId, userEmail, taskId.toString(), runId, runDir, prompt, null, null);
    res.set({
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive'
    });
    res.flushHeaders();
    res.write('data: ' + JSON.stringify({ event: 'taskStart', payload: { taskId: taskId.toString(), command: prompt, startTime: new Date() } }) + '\n\n');
    // poll for updates
    const interval = setInterval(async () => {
      try {
        const task = await Task.findById(taskId).lean();
        if (!task) {
          clearInterval(interval);
          res.write('data: ' + JSON.stringify({ event: 'taskError', taskId: taskId.toString(), error: 'Task not found' }) + '\n\n');
          return res.end();
        }
        const done = ['completed','error'].includes(task.status);
        const evtName = done ? 'taskComplete' : 'stepProgress';
        const payload = { taskId: taskId.toString(), progress: task.progress, result: task.result, error: task.error };
        res.write('data: ' + JSON.stringify({ event: evtName, ...payload }) + '\n\n');
        if (done) {
          clearInterval(interval);
          return res.end();
        }
      } catch (err) {
        console.error('Task polling error:', err);
      }
    }, 2000);
    req.on('close', () => clearInterval(interval));
  } else {
    // chat streaming
    res.set({
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      Connection: 'keep-alive'
    });
    res.flushHeaders();
    for await (const evt of streamNliThoughts(userId, prompt)) {
      res.write('data: ' + JSON.stringify(evt) + '\n\n');
    }
    res.end();
  }
});
